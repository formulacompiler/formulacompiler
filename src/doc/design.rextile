
h1. SEJ Design Document


<div class="news">

More and better diagrams!
<br/>%(when)May 17, 2006%

</div>

The Spreadsheet Engine for Java (SEJ, for short) makes it possible to use computations defined in spreadsheet files within normal Java applications. The original spreadsheet files can be created, for example, in "Microsoft Excel":-excel or "OpenOffice Calc":-ooc. SEJ reads the spreadsheet files and builds corresponding Java-based formula evaluation engines. Such an engine computes output values given a set of input values.

<%= toc 2, 3 %>


h2. Overview

Here's an overview of how SEJ does this. Blue is your code, red is SEJ's, green are external dependencies, and yellow are generated things:

!embedded.png(Overview)!

For example, compute the value of the cell _B3_ given the values of the cells _B1_ and _B2_ as inputs in:

	[xc:testdata/sej/examples/test.xls]

The following code does this:

	[jc:sej.examples.BasicUsageDemo:---- BasicUsage; strip ---- Computation; strip ---- Construction]



h2. Design Goals


h3. Multiple Data Formats

SEJ should be usable with at least Microsoft Excel XLS and XML files, and OpenOffice Calc files.


h3. High Performance Computation

The generated engines should be suitable for use on application servers:

	* Low memory consumption
	* High performance
	* Thread safe


h3. High Performance Engine Construction

The generation of an engine from a spreadsheet file, however, is considered a rarer task. So, while the above goals are still desirable for it, the focus is clearly on making the engines perform exceptionally well, not engine generation. Nevertheless, engine generation must be suitable for being performed occasionally by an application server.


h3. Cheap Instantiation

Because generation of an engine may be an expensive task, it must be possible to store generated engines and then later efficiently instantiate them from the storage. The original spreadsheet file should not be required for this instantiation.


h3. Usability

Errors in the spreadsheet file or errors during engine generation due to limitations of SEJ must be pinpointed and described in a way that allows typical spreadsheet users to correct or work around the problem.


h3. Documentation

The range of supported formula elements must be clearly documented using automated tests.


h3. <a name="trust">Trustworthiness</a>

SEJ in its standard operation generates byte code for the Java VM. This is not something most programmers read and understand with ease. SEJ must therefore also be able to generate Java source code. All automated tests should run both with bytecode and with sourcecode generation, and the tests should ascertain that the bytecode compiled from the source by the Java compiler is the same as the one compiled by directly by SEJ. This way, users who mistrust bytecode generation, or who need to see what an engine generated by SEJ does internally, can rely on the generated source code.



h2. Design

Derived from the design goals above is a clear separation of phases and concerns into individual components:

!compiler.png(Compiler Overview)!


<dl>

<dt>API Facade</dt><dd>(Not shown in diagram.) Defines the public API to all of SEJ. For example, the interfaces @Engine@ and @Computation@.</dd>

<dt>Spreadsheet Model</dt><dd>An in-memory representation of a spreadsheet which is constructed by loaders and consumed by engine builders. It thus decouples the engine compilers from the various spreadsheet formats supported by SEJ. Cell formulas are represented by expression trees with special nodes denoting cell references. Parsing of cell formulas into expression trees can be done lazily so that only the formulas actually used by an engine builder are parsed.</dd>

<dt>Computation Model</dt><dd>An in-memory representation of the relevant computation extracted from a spreadsheet model. This model is hierarchical to represent dynamic sections and has no longer any notion of rows and columns, only of expressions referencing inputs or other expressions.</dd>

<dt>Expression Trees</dt><dd>A syntax tree representation of the formulas found in a spreadsheet or an internal computation model.</dd>

<dt>Spreadsheet Compiler</dt><dd>Compiles a spreadsheet model into an internal computation model. Uses the engine definition (inputs and outputs) to extract only the relevant parts.</dd>

<dt>Optimizer</dt><dd>Performs constant folding and expression inlining on the internal computation model.</dd>

<dt>Abstract Excel Loader</dt><dd>Common base for the different Microsoft Excel spreadsheet file loaders (.xls and .xml). Implements lazy parsing of Excel formulas into SEJ's expression trees. The expression parser is generated using the open-source JFlex and CUP components.</dd>

<dt>Excel .xls Loader</dt><dd>Loads spreadsheet files in Microsoft Excel's native .xls format into an SEJ spreadsheet model. Uses the open-source JExcelAPI library to parse the .xls format.</dd>

<dt>Excel .xml Loader</dt><dd>Loads spreadsheet files in Microsoft Excel's .xml format into an SEJ spreadsheet model. Uses the open-source JDOM library to parse the XML file into a DOM.</dd>

<dt>OpenOffice .ods Loader</dt><dd>Envisioned loader(s) for the OpenOffice spreadsheet file format(s).</dd>

<dt>SEJ Bytecode Compiler</dt><dd>Builds an SEJ engine given an internal computation model. Uses the open-source ASM library to generate the new engine class and the methods which compute the spreadsheet formulas. The generated class can be used directly to instantiate an engine, or else stored somewhere for later instantiation. It is thus possible to build the engine in a separate configuration program and then install only the generated class file with its minimal dependencies in a server application.</dd>

<dt>Engine Instance</dt><dd>Expression evaluation engine that computes formulas using native Java byte code methods. Some computations of core spreadsheet functions are delegated to a SEJ runtime library (not shown). This implementation of an engine is very fast and space efficient. It also has no other dependencies on external components. It is, therefore, an ideal choice for heavily used server-side computations.</dd>
</dl>




h2. Realization of Design Goals

How are the design goals addressed by this design?


h3. Multiple Data Formats

The design decouples the engines and engine builders completely from the physical representation of spreadsheets in files. This makes it fairly straightforward and inexpensive to add new formats. Use of JFlex/CUP to generate the formula expression parsers makes supporting new expression syntaxes fairly easy.

SEJ has a simple workbook loader registry. Once appropriate loaders are registered, a spreadsheet file can be opened with a generic call. The loaders look at the file's extension to determine the appropriate one to use.


h3. High Performance Computation

The separation of the Engine and Computation interfaces allows the concurrent use of an engine across multiple threads. Each thread simply creates its own computations on the central engine. Engines are thus fully thread-safe and non-blocking.

	[jc:sej.examples.BasicUsageDemo:---- Computation]

The byte code engine is extremely fast as all necessary expressions from the spreadsheet model - after constant folding - have been compiled to native Java byte code. A byte code engine depends neither on the spreadsheet model nor on anything else except for SEJ's runtime classes.


h3. High Performance Engine Construction

As stated above, in most scenarios performance of the construction of engines is not as critical as performance of the constructed engines themselves. Nevertheless, the design should allow for optimization of engine construction should it become necessary.

Engine construction can be separated into two distinct steps:

	# Parse the spreadsheet file into an SEJ spreadsheet model.
	# Construct an engine (or multiple different engines) from the model for a given set of inputs from which the engine is to be able to compute a given set of outputs.

	[jc:sej.examples.BasicUsageDemo:---- Construction]

SEJ's spreadsheet model should be designed so as to allow loaders to instantiate parts of the model lazily. This will in principle allow engines to be constructed efficiently which access only a small part of an otherwise large spreadsheet. The true need for this is not totally clear at the moment, however, because I expect users to write dedicated spreadsheets that supply computations to business applications. Currently, lazy parsing of expressions is already implemented and thus verified. Lazy instantiation of individual sheets, rows, and cells is not yet implemented and may still require some interface changes affecting both loaders and engine builders.

Use of JFlex/CUP should ensure efficient expression parsers.

Construction of an engine from an SEJ model is fairly straightforward and thus fairly cheap.


h3. Cheap Instantiation

First of all, an engine, once compiled, does not depend on the original spreadsheet file, its internal model, or the compiler used to compile the engine. It also does not have any dependencies on third party libraries. So if an engine can be serialized to persistent storage, it can be deserialized again with little cost and no external dependencies. It is therefore a possible and, indeed, recommended scenario that applications should take spreadsheet files as input during configuration and compile the necessary computation engines from them. They should then store the engines somewhere for use later on at run-time. In addition to improving the production server's memory footprint and performance, this will also minimize the security risk introduced by the access to arbitrary, user-supplied spreadsheet files. This access can be delegated to an offline configuration editor, instead of being part of the production server.

Here's the general outline of such an approach:

!compile_and_use.png(Separate Compilation)!

First, the configuration, which compiles an engine and stores it somewhere (a file in this example):

	[jc:sej.examples.EngineSerializationDemo:---- Serialization]

Second, the code that would run in a production server:

	[jc:sej.examples.EngineSerializationDemo:---- Deserialization]

Note that the production server must have called StandardEngine.register() somewhere so the EngineFactory knows what type of engine to instantiate.

The byte code engine is really a Java class generated at run-time. Its serialization is, therefore, simply the byte array that would be stored in the .class file. Note, however, that this byte array can be stored anywhere, it need not be an actual .class file somewhere on your classpath. Instantiation of a byte code engine from external storage is, therefore, exactly what a class loader does.


h3. Usability

This goal has not been specifically addressed in the current design. However, the use of JFlex/CUP to generate the expression parsers should lead to fairly good error messages when unsupported or erroneous expressions are encountered.


h3. Documentation

Use of JFlex/CUP to generate the expression parsers leads to a fairly readable documentation of the supported (or, at least, parsed) expression syntax.

Test-driven development should ensure that all supported features are clearly documented and verified by tests. The infrastructure to add tests in a consistent way is not documented yet.


h3. Trustworthiness

While not implemented yet, SEJ will be able to generate Java source code as well as byte-code:

!compilesrc_and_use.png(Source Compilation)!
