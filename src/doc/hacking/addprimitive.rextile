
h1. Adding A New Primitive Spreadsheet Function To SEJ


As a simple, but probably typical example, we will look at how I added @ABS()@ to the list of supported spreadsheet functions. So for the rest of this page, we will assume @ABS()@ has not been implemented yet.

<%= toc 2, 4 %>


h2. _Rule 1_: <br/>Document first

Documentation, well, documents, but it also "focuses our thinking":-tdd. This is why we start with it - and, of course, so we don't forget it. For larger, novel features, it can be "quite elaborate":../tutorial/generatesheet.htm. In our case, we may safely assume that people know why we would want @ABS()@ to be supported, and that they will consult the Excel help file for information on it.

h4. Release Notes

Nevertheless, we still need to document that @ABS()@ is, in fact, supported. First, we announce the improvement in the release notes in @src/doc/releasenotes.rextile@. Just look at the file and you'll see how (as per the house rule _mimick existing code_).

h4. Rextile

SEJ's documentation is written in "Textile":-tex, a very concise and text editor-friendly format for writing XHTML. To convert the Textile sources to XHTML, we use "Rextile":-rex -- a "Ruby":-rb based tool. You will need to "install it":tools.htm. Once it's installed, you can simply run "ant doc":build.htm to regenerate the documentation in @doc/@ from the sources in @src/doc/@. (It is much quicker to run @ant rextile@ if you just want see the updated release notes, and can live with some warnings and missing citations.)



h2. _Rule 2_: <br/>Cite tests

So far, we simply said: <em>@ABS()@ is supported</em>. How do we know it is? How does the reader know? This is where test-driven development gets into the picture - with a twist. We prove what we say directly to our reader. The proof becomes an integral part of the documentation (which is, after all, _what we are saying_). So, to integrate the proof, we always give examples which are "_cited_ from automated tests":-citing.

SEJ's existing testing and citing infrastructure makes this easy, especially for adding a new spreadsheet function. The spreadsheet files in @src/test-system/testdata/sej/tests/reference@ contain formula tests. So, to prove we implemented @ABS()@, all we still need to do is add test cases to one of the test sheets.


h2. Automated Formula Tests

The spreadsheet files in @src/test-system/testdata/sej/tests/reference/@ contain formula tests. For @ABS()@, we extend the sheet called @NumericFunctions.xls@. By _citing_ it, I can show it right here (only the relevant subset is shown):

	[xc:testdata/sej/tests/reference/NumericFunctions.xls:HeaderRange,ABSRange]

And here is "the documentation produced from it":../reference/numfuncs.htm. Note also how the list of supported functions in the "reference index":-ref automatically includes @ABS@.

See here for "details on exactly what the columns of this sheet mean":-reftest.


h2. _Rule 3_: <br/>Mimick existing code

This rule is the _monkey see, monkey do_ rule from the book on "contributing to Eclipse":-ecrules. It means we look for an already implemented function closely matching @ABS()@, and then mimick its implementation and "code style":style.htm (aka copy/paste). We will mimick @ROUND()@ for @ABS()@. In fact, we already did. When documenting @ABS()@ in the list of supported functions, remember? This rule basically states something we would do anyway.

So, to add the test cases for @ABS()@, I already copied lines from @ROUND()@ and adjusted them. You can see them in the sheet above. (Copying the lines made sure that the conditional formatting for input values was copied too.)


h2. _Rule 4_: <br/>Implement only what the tests require

This is test-driven development. We implement @ABS()@ by just adding missing code until the tests run. The first step is, then, to run the tests just added (which will fail, of course). Every formula test sheet corresponds to a test class in @src/test-system/sej/tests/reference@. For the sheet @NumericFunctions.xls@, we need to run the test class @NumericFunctionsTest@. Doing this now returns:

<pre><code
>sej.SpreadsheetException$UnsupportedExpression:
  Undefined name or unsupported function encountered in expression ABS( <<? C2);
  error location indicated by <<?.
  Cell containing expression is B2.
at sej.internal.spreadsheet.CellWithLazilyParsedExpression.getExpression(CellWithLazilyParsedExpression.java:71)
...
</code></pre>

Running these tests can take quite a while. See here for "how to speed this up":-dbgtest.


h2. Extending The Parser

_Undefined name or unsupported function encountered_ means SEJ's Excel formula parser cannot parse something. So we must make it support @ABS()@ as our first implementation step. The parser consists of two separate phases, the lexical scanner returning symbols, and the symbol stream parser. Both are generated from special scanner and parser description languages.

The scanner is generated using "JFlex":-jflex. Its input file is @src/classes/sej/internal/spreadsheet/loader/excel/ExcelExpressionScanner.lex@. To add support for recognizing the @ABS@ token, we simply add the following line above the one for @ROUND@:

<pre><code
>{FN} "ABS" { return new Symbol( GeneratedSymbols.ABS, "ABS" ); }
</code></pre>

We run @ant build@ to regenerate the scanner. This leads to the next error. The Java symbol @GeneratedSymbols.ABS@ is undefined. This is because the parser defines the available symbols. So we need to tell the token parser about @ABS@, too.

The parser is generated using "CUP":-cup. Its input file is @src/classes/sej/internal/spreadsheet/loader/excel/ExcelExpressionParser.cup@. To add support for recognizing the @ABS()@ function, we first add the symbol @ABS@:

<pre><code
>terminal MATCH, INDEX, ROUND, ABS;
</code></pre>

Then we add parsing instructions for the entire @ABS()@ function. They go into the definition of the @expr@ clause:

<pre><code
>expr ::=
  ...
  |  ABS LPAREN expr:e RPAREN
       {: RESULT = new ExpressionNodeForFunction( Function.ABS, e ); :}
</code></pre>

This should be fairly self-explanatory. It creates a new expression node for a function @ABS@ with a single argument @e@, which can be any expression. To generate the parser, we run @ant build@ again.

Now, the Java symbol @sej.Function.ABS@ is undefined. Extending this enumeration is straightforward. We do it, and the code compiles again.


h2. Implementing The Function

Running the test again, we get:

<pre><code
>sej.CompilerException$UnsupportedExpression:
Function ABS is not supported for double engines.
In expression  >> ABS( C2 ) << ; error location indicated by >>..<<.
Cell containing expression is B2.
Referenced by cell B2.
  at sej.internal.bytecode.compiler.ExpressionCompiler.compileFunction(ExpressionCompiler.java:334)
  at sej.internal.bytecode.compiler.ExpressionCompilerForNumbers.compileFunction(ExpressionCompilerForNumbers.java:293)
  at sej.internal.bytecode.compiler.ExpressionCompiler.compileInner(ExpressionCompiler.java:185)
  at sej.internal.bytecode.compiler.ExpressionCompiler.compile(ExpressionCompiler.java:112)
  at sej.internal.bytecode.compiler.MethodCompiler.compileExpression(MethodCompiler.java:261)
  at sej.internal.bytecode.compiler.CellMethodCompiler.compileBody(CellMethodCompiler.java:79)
  at sej.internal.bytecode.compiler.MethodCompiler.compile(MethodCompiler.java:112)
  at sej.internal.bytecode.compiler.CellComputation.compile(CellComputation.java:89)
  at sej.internal.bytecode.compiler.ByteCodeEngineCompiler$ElementCompiler.visitTargetCell(ByteCodeEngineCompiler.java:218)
  at sej.internal.bytecode.compiler.ByteCodeEngineCompiler$AbstractElementVisitor.visit(ByteCodeEngineCompiler.java:271)
</code></pre>

This is from the heart of SEJ, the byte code compiler. To implement @ABS()@, let's look at how @ROUND()@ is implemented. This is where I have to introduce you to one of the niftier parts of SEJ: the JVM(Java Virtual Machine) byte-code decompiler.

h4. Template Methods

SEJ is, like @javac@, a byte-code compiler for the JVM(Java Virtual Machine). But, luckily, you don't have to know the "JVM byte code instruction set":-jvminsns to add primitive functions like @ABS()@ to SEJ. Instead, you write simple _template methods_ in plain Java, like this:

	[jc:sej.internal.templates.ExpressionTemplatesForDoubles:---- fun_ROUND]

Any method you put into the class

	sej.internal.templates.ExpressionTemplatesForDoubles
	
that is called @fun_XY@ is automatically decompiled by SEJ's build process to generate a byte-code compiler for expression nodes of the kind @new ExpressionNodeForFunction( Function.XY )@.

h4. Expression Rewriting

There is another approach for functions that can be rewritten to expressions involving only other, more primitive expression functions. This is shown in the topic on "adding high-level functions":-prim.

h4. Runtime Support

As you can see, @ROUND()@ is not implemented directly, but mapped to a runtime support function. The runtime is subclassed for each supported "numeric type":-types. It is also versioned so SEJ can easily provide backwards compatibility with older compiled engines. Here is the implementation from @sej.internal.runtime.RuntimeDouble_v1@:

	[jc:sej.internal.runtime.RuntimeDouble_v1:---- round]

h4. Numeric Types

This would be very easy to do for @ABS()@ too. But @ABS()@ is really so basic, we will implement it directly instead:

	[jc:sej.internal.templates.ExpressionTemplatesForDoubles:---- fun_ABS]

This covers @double@. We also need to handle @BigDecimal@ and scaled @long@. This is done in the template class @sej.internal.templates.ExpressionTemplatesForScaledLongs@:

	[jc:sej.internal.templates.ExpressionTemplatesForScaledLongs:---- fun_ABS]
	
and in @sej.internal.templates.ExpressionTemplatesForBigDecimals@:

	[jc:sej.internal.templates.ExpressionTemplatesForBigDecimals:---- fun_ABS]

The annotation @@ReturnsAdjustedValue@ means that the method result already has the proper scale. If you omit it, SEJ will generate rescaling code after your method body. Once this is done, run "@ant generate@":build.htm to rebuild the compiler code from the template methods.

dt. Note : With "Eclipse":-ec, it is crucial to use @ant generate@ to update the compiler code rather than running @sej.internal.build.bytecode.PatternCompiler@ directly from within the IDE. This is because Eclipse's compiler produces different byte-code sequences for the pattern methods than @javac@ as invoked by SEJ's "build script":build.htm. While Eclipse's version is also correct, it breaks the binary comparisons of generated engines with reference versions in some of the unit tests for SEJ (see @sej.tests.utils.AbstractTestBase.checkEngine()@ in @src/test-unit/@.


h2. Conclusion

That's it. All the tests run green. Running "@ant doc@":build.htm updates the documentation and -- lo and behold -- @ABS()@ is now included and fully documented. (Hint: If you just ran the full tests, @ant rextile cite@ is way faster because @ant doc@ runs the tests again.)

Now read on to see that other approach using expression rewriting: "adding high-level functions":-high.
