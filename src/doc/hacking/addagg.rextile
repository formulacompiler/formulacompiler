<% @html_name = html_name.chomp( '.htm' ) + '.xhtml' %>

h1. Adding A New Aggregator Function To SEJ

An aggregator is a (typically statistical) function that computes a single value from a range of values. @SUM()@ is the prime example. Here, we shall look at how I implemented @VAR()@. So let's assume @VAR()@ has not been implemented yet.

_Note: You must have read the topics on adding "primitive functions":-prim and "high-level functions":-high to understand this section._

<%= toc 2, 4 %>


h2. Docs and Tests

As always, we start with the announcement in the release notes, and the tests:

	[xc:testdata/sej/tests/reference/Aggregators.xls:CiteHeader,CiteVAR]

	
h2. Parsing

Making @VAR()@ known to the parser is much like what we did for @ABS()@. Aggregators, however, need to accept range arguments, not just simple values. For the standard aggregators which treat all their arguments as a single range, we can extend the definition of @agg@ as follows:

	agg ::=
			SUM
					{: RESULT = Function.SUM; :}
		...
		| 	VAR
					{: RESULT = Function.VAR; :}		
		...


h2. Mathematical Definition
	
The function @VAR()@ is defined in the Excel help file as follows:

<notextile><math xmlns='http://www.w3.org/1998/Math/MathML' display='block'>
	<mfrac><mrow><mo lspace="thinmathspace" rspace="thinmathspace">&#8721;</mo>
	<mrow><mo>(</mo>
	<mi>x</mi><mo>-</mo><mover><mrow><mi>x</mi>
	</mrow><mo>&#x000AF;</mo></mover><msup><mo>)</mo> <mn>2</mn></msup></mrow></mrow><mrow>
	<mi>n</mi><mo>-</mo><mn>1</mn></mrow></mfrac>
</math></notextile>

Clearly, what we have here is a sum over a function on _all of the elements_ in the range. How can we rewrite this using Excel functions? We cannot. But SEJ defines a couple of "functions of its own":-refrewrite that help.


h2. Folding Functions

For a quick example, let's look at how the rewrite rule for @SUM()@ is defined in SEJ:

	[jc:sej.internal.build.rewriting.RewriteRulesCompiler:---- fun_SUM]

This means that the result, @r@, is initially 0. Then, for every @xi@ in the range @xs@, we simply add @xi@ to @r@. In the argument specification, the @*@ indicates that @xs@ represents all remaining arguments as a list (much like @int... a@ in Java).

So the "folding function":-funfold iterates over a list of arguments. For every value in the list, it executes a given computation involving a so-called _accumulator value_ (called @r@ here) and the current value from the list (called @xi@ here). The result becomes the new accumulator value. The final result is the accumulator value at the end of the list.

h4. Special First Argument

The version of @_FOLD()@ I used here, @_FOLD_OR_REDUCE()@, is simply @_FOLD()@ with a hint that it is OK to directly use the first argument as the starting value, instead of the specified value 0. This is a performance optimization.

There are also cases when it is _mandatory_ to use the first argument directly. @MIN()@ and @MAX()@ are such cases (so we don't need some arbitrary starting extremal value). For them you need to use @_REDUCE()@:

	[jc:sej.internal.build.rewriting.RewriteRulesCompiler:---- fun_MINMAX]

You read this as follows:

	* The accumulator is implicitly initialized with the first list element unchanged.
	* For all other list elements, @xi@, and the current accumulator, @r@, the new accumulator is the result of applying the binary min/max operator to the two values. These operators are "primitive operators":-prim I added to SEJ precisely so I could then use @_REDUCE()@ for @MIN()@ and @MAX()@.
	* If the list is empty, the result is 0 (as specified in the third argument).
	* Otherwise, the final result is, again, the value of the accumulator at the end of the list.


h2. Rewriting It

Let's recap the mathematical definition:

<notextile><math xmlns='http://www.w3.org/1998/Math/MathML' display='block'>
	<mfrac><mrow><mo lspace="thinmathspace" rspace="thinmathspace">&#8721;</mo>
	<mo>(</mo><msub><mi>x</mi> <mi>i</mi></msub><mo>-</mo><mover><mrow><mi>x</mi>
	</mrow><mo>&#x000AF;</mo></mover><msup><mo>)</mo> <mn>2</mn></msup></mrow><mrow><mi>n</mi>
	<mo>-</mo><mn>1</mn></mrow></mfrac>
</math></notextile>

where the average is, of course, defined as:

<notextile><math xmlns='http://www.w3.org/1998/Math/MathML' display='block'>
	<mover><mi>x</mi><mo>&#x000AF;</mo></mover>
	<mo>=</mo><mfrac><mrow><mo lspace="thinmathspace" rspace="thinmathspace">&#8721;</mo>
	<msub><mi>x</mi> <mi>i</mi></msub></mrow><mrow><mi>n</mi>
	</mrow></mfrac>
</math></notextile>

Clearly, we will need the two auxiliary values

	* _n_ = @COUNT(xs)@, and
	* _m_ = @AVERAGE(xs)@ = @SUM(xs) / COUNT(xs)@ = @SUM(xs) / `n@

to define the overall result. In SEJ's rewriting rules you can define auxiliary values using the @_LET()@ function. So we arrive at:

	[jc:sej.internal.build.rewriting.RewriteRulesCompiler:---- fun_VAR]

Note how we can use @SUM()@ in the rule, even though it is itself a high-level aggregation with a rewrite rule of its own. SEJ applies rewrites recursively until there is no more to rewrite.
