
h1. Caching Of Values and Reusing Computations

Many computations can be sped up by turning on internal caching of cell values. And some functions (@NOW@ and @MATCH@, for example), or repeating sections, _always_ use internal caches. Caches, however, introduce state. You need to reset this state when reusing computations on modified inputs.

<%= toc 2, 3 %>


h2. Why Cache?

Consider the following very simple example spreadsheet doing the computation of a square's area and a cube's volume, given the side length. The cell B1 is the sole input, B3 and B4 are outputs.

	[xc:org/formulacompiler/tutorials/Caching.xls]

Turning on internal caching would give us the following benefits.

dt. Intermediate Values : The _area_ is reused by the _volume_ computation. Even in this simple example, if you compute millions of areas and volumes using @BigDecimal@ and side lengths of great precision, the cache pays off.

dt. Input Values : The input _side length_ is used three times in all. Assuming it is expensive to obtain (maybe it involves a database access), the cache will also pay off. You could, of course, cache this value yourself. But since AFC supports automatic internal caching anyway, you can save yourself the trouble.

dt. Output Values : Finally, AFC also caches output values. So if you access them multiple times, you benefit without having to cache them yourself.

h5. Note

Caching of input and output values also encourages a functional view of computations, i.e. input value accessors that have no side effects. Since you cannot know beforehand how many times a spreadsheet will access your input values, having side effects in them is very likely a bad idea.


h2. No Caching Is Standard

Normally, computations generated by AFC do not cache values internally, except for some special functions. The reason is that the overhead introduced by caching is not warranted for simple, straightforward computations. Here is an example of this, where we count the number of accesses to the input, the _side length_:

	[jc:org.formulacompiler.tutorials.Caching:---- noCacheAccesses]

h5. Note

This stateless behaviour is not guaranteed. AFC _always_ caches repeating sections, and certain functions. @NOW@, for example, is required to return the same value for the entire duration of a computation, so AFC caches the value returned on the first invocation. See further below for details.


h2. Turning On Caching

Let's now turn on explicit, full caching:

	[jc:org.formulacompiler.tutorials.Caching:---- compile]

Here's what happens if we run the above example again, but with caching enabled:

	[jc:org.formulacompiler.tutorials.Caching:---- cacheAccesses]

The input is only accessed once.

h5. Was it worth it?
In this example, does caching pay off? Let's compare the speed of computing the area and volume with and without caching for a largish value of _side_:

	[jc:org.formulacompiler.tutorials.Caching:---- timed]

We find that caching is faster by more than than half:

	[jc:org.formulacompiler.tutorials.Caching:---- timing]


h2. <a name="reuse">Reusing Computations</a>

As I said before, computations generated by AFC do not normally cache values internally, unless you explicitly turn on caching. This might lead you to believe that a computation behaves correctly when you call it multiple times while, in between, modifying the data returned by its input object. Here is an example of this:

	[jc:org.formulacompiler.tutorials.Caching:---- noCache]

This is not guaranteed, however! AFC makes no promise to not cache internally. And what works now might not work in a future release of AFC. (In fact, for functions like @NOW@ it always has to cache, because @NOW@ is required to return the same value for the duration of a single computation.) And what about reusing computations where we _do_ turn on caching? Here's what happens if we run the above example again, with internal caching:

	[jc:org.formulacompiler.tutorials.Caching:---- cache]

Note how changing the input value does *not* affect the output values. The are still cached from the previous use.

h5. @reset()@

We have to be able to _reset_ a computation when we have modified its input. AFC supports this if our output interface or class implements the @Resettable@ interface:

	[jc:org.formulacompiler.runtime.Resettable:---- resettable]

It does:

	[jc:org.formulacompiler.tutorials.Caching:---- Output]
	
so let's do this properly:

	[jc:org.formulacompiler.tutorials.Caching:---- reset]


h2. Caching Internals

h5. Non-caching

The generated non-caching computation is:

	[jc:caching/plain/org.formulacompiler.gen.$Root]

h5. Caching

With caching, it is:

	[jc:caching/caching/org.formulacompiler.gen.$Root]

Clearly, this is a lot more code than for the non-caching version. It is important to realize, however, that AFC only caches intermediate cell values which are referenced more than once in the computation. All others are inlined into the single expression that references them. Cells that are not referenced at all don't appear in the computation at all, either.

