
h1. Design Overview

The Abacus Formula Compiler (AFC) makes it possible to use computations defined in spreadsheet files within normal Java applications. The original spreadsheet files can be created, for example, in "Microsoft Excel":-excel or "OpenOffice Calc":-ooc. AFC reads the spreadsheet files and builds corresponding Java-based formula evaluation engines. Such an engine computes output values given a set of input values.

<%= toc 2, 3 %>


h2. Overview

Here's an overview of how AFC does this. Blue is your code, red is AFC's, green are external dependencies, and yellow are generated things:

!embedded.png(Overview)!


h3. Example

For example, compute the value of the cell _B3_ given the values of the cells _B1_ and _B2_ as inputs in:

	[xc:org/formulacompiler/examples/test.xls]

The following code does this:

	[jc:org.formulacompiler.examples.BasicUsageDemo:---- BasicUsage; strip ---- Computation; strip ---- Construction]

	
h3. Generated Code
	
The call to @builder.compile()@ internally generates JVM byte code. When decompiled, the code looks as follows. It consists of the computation engine:

	[jc:basicusage.org.formulacompiler.gen.$Root]

and its factory:

	[jc:basicusage.org.formulacompiler.gen.$Factory]


h2. Design Goals


h3. Multiple Data Formats

AFC should be usable with at least Microsoft Excel XLS and XML files, and OpenOffice Calc files.


h3. High Performance Computation

The generated engines should be suitable for use on application servers:

	* Low memory consumption
	* High performance
	* Thread safe


h3. High Performance Engine Construction

The generation of an engine from a spreadsheet file, however, is considered a rarer task. So, while the above goals are still desirable for it, the focus is clearly on making the engines perform exceptionally well, not engine generation. Nevertheless, engine generation must be suitable for being performed occasionally by an application server.


h3. Cheap Instantiation

Because generation of an engine may be an expensive task, it must be possible to store generated engines and then later efficiently instantiate them from the storage. The original spreadsheet file should not be required for this instantiation.


h3. Usability

Errors in the spreadsheet file or errors during engine generation due to limitations of AFC must be pinpointed and described in a way that allows typical spreadsheet users to correct or work around the problem.


h3. Documentation

The range of supported formula elements must be clearly documented using automated tests.


h3. <a name="trust">Trustworthiness</a>

AFC in its standard operation generates byte code for the Java VM. This is not something most programmers read and understand with ease. AFC must therefore be able to generate Java source code. All automated tests should ascertain that the bytecode compiled from the source by the Java compiler is the same as the one compiled by directly by AFC. This way, users who mistrust bytecode generation, or who need to see what an engine generated by AFC does internally, can rely on the generated source code.



h2. Design

Derived from the design goals above is a clear separation of phases and concerns into individual components:

!compiler.png(Compiler Overview)!

dt. API Facade : (Not shown in diagram.) Defines the public API to all of AFC. For example, the interfaces @Engine@ and @Computation@.

dt. Spreadsheet Model : An in-memory representation of a spreadsheet which is constructed by loaders and consumed by engine builders. It thus decouples the engine compilers from the various spreadsheet formats supported by AFC. Cell formulas are represented by expression trees with special nodes denoting cell references. Parsing of cell formulas into expression trees can be done lazily so that only the formulas actually used by an engine builder are parsed.

dt. Computation Model : An in-memory representation of the relevant computation extracted from a spreadsheet model. This model is hierarchical to represent dynamic sections and has no longer any notion of rows and columns, only of expressions referencing inputs or other expressions.

dt. Expression Trees : A syntax tree representation of the formulas found in a spreadsheet or an internal computation model.

dt. Spreadsheet Compiler : Compiles a spreadsheet model into an internal computation model. Uses the engine definition (inputs and outputs) to extract only the relevant parts.

dt. Optimizer : Performs constant folding and expression inlining on the internal computation model.

dt. Spreadsheet Loader : Subsystem containing the different spreadsheet file loaders (Excel .xls and .xml, and OpenOffice). Implements lazy parsing of formulas into AFC's expression trees. The expression parser is generated using the open-source "JavaCC":-javacc library.

dt. Excel .xls Loader : Loads spreadsheet files in Microsoft Excel's native .xls format into an AFC spreadsheet model. Uses the open-source "JExcelAPI":-jxl library to parse the .xls format.

dt. Excel .xml Loader : Loads spreadsheet files in Microsoft Excel's .xml format into an AFC spreadsheet model.

dt. OpenOffice .ods Loader : Envisioned loader(s) for the OpenOffice spreadsheet file format(s).

dt. Bytecode Compiler : Builds an AFC engine given an internal computation model. Uses the open-source "ASM":-asm library to generate the new engine class and the methods which compute the spreadsheet formulas. The generated class can be used directly to instantiate an engine, or else stored somewhere for later instantiation. It is thus possible to build the engine in a separate configuration program and then install only the generated class file with its minimal dependencies in a server application.

dt. Engine Instance : Expression evaluation engine that computes formulas using native Java byte code methods. Some computations of core spreadsheet functions are delegated to a AFC runtime library (not shown). This implementation of an engine is very fast and space efficient. It also has no other dependencies on external components. It is, therefore, an ideal choice for heavily used server-side computations.

dt. Bytecode Decompiler : Generates the Java source code for a compiled AFC engine using the open-source "JODE":-jode library. This is mainly for debugging and for inspecting generated engines.



h2. Realization of Design Goals

How are the design goals addressed by this design?


h3. Multiple Data Formats

The design decouples the engines and engine builders completely from the physical representation of spreadsheets in files. This makes it fairly straightforward and inexpensive to add new formats. Use of JavaCC to generate the formula expression parsers makes supporting new expression syntaxes fairly easy.

AFC has a simple workbook loader registry. Once appropriate loaders are registered, a spreadsheet file can be opened with a generic call. The loaders look at the file's extension to determine the appropriate one to use.


h3. High Performance Computation

The separation of the Engine and Computation interfaces allows the concurrent use of an engine across multiple threads. Each thread simply creates its own computations on the central engine. Engines are thus fully thread-safe and non-blocking.

	[jc:org.formulacompiler.examples.BasicUsageDemo:---- Computation]

The byte code engine is extremely fast as all necessary expressions from the spreadsheet model - after constant folding - have been compiled to native Java byte code. A byte code engine depends neither on the spreadsheet model nor on anything else except for AFC's runtime classes.


h3. High Performance Engine Construction

As stated above, in most scenarios performance of the construction of engines is not as critical as performance of the constructed engines themselves. Nevertheless, the design should allow for optimization of engine construction should it become necessary.

Engine construction can be separated into two distinct steps:

	# Parse the spreadsheet file into an AFC spreadsheet model.
	# Construct an engine (or multiple different engines) from the model for a given set of inputs from which the engine is to be able to compute a given set of outputs.

	[jc:org.formulacompiler.examples.BasicUsageDemo:---- Construction]

AFC's spreadsheet model should be designed so as to allow loaders to instantiate parts of the model lazily. This will in principle allow engines to be constructed efficiently which access only a small part of an otherwise large spreadsheet. The true need for this is not totally clear at the moment, however, because I expect users to write dedicated spreadsheets that supply computations to business applications. Currently, lazy parsing of expressions is already implemented and thus verified. Lazy instantiation of individual sheets, rows, and cells is not yet implemented and may still require some interface changes affecting both loaders and engine builders.

Use of JavaCC should ensure efficient expression parsers.

Construction of an engine from an AFC model is fairly straightforward and thus fairly cheap.


h3. Cheap Instantiation

First of all, an engine, once compiled, does not depend on the original spreadsheet file, its internal model, or the compiler used to compile the engine. It also does not have any dependencies on third party libraries. So if an engine can be serialized to persistent storage, it can be deserialized again with little cost and no external dependencies. It is therefore a possible and, indeed, recommended scenario that applications should take spreadsheet files as input during configuration and compile the necessary computation engines from them. They should then store the engines somewhere for use later on at run-time. In addition to improving the production server's memory footprint and performance, this will also minimize the security risk introduced by the access to arbitrary, user-supplied spreadsheet files. This access can be delegated to an offline configuration editor, instead of being part of the production server.

Here's the general outline of such an approach:

!compile_and_use.png(Separate Compilation)!

First, the configuration, which compiles an engine and stores it somewhere (a file in this example):

	[jc:org.formulacompiler.examples.EngineSerializationDemo:---- Serialization]

Second, the code that would run in a production server:

	[jc:org.formulacompiler.examples.EngineSerializationDemo:---- Deserialization]

Note that the production server must have called StandardEngine.register() somewhere so the EngineFactory knows what type of engine to instantiate.

The byte code engine is really a Java class generated at run-time. Its serialization is, therefore, simply the byte array that would be stored in the .class file. Note, however, that this byte array can be stored anywhere, it need not be an actual .class file somewhere on your classpath. Instantiation of a byte code engine from external storage is, therefore, exactly what a class loader does.

It should be noted that this design emphasizes using a few engines often as opposed to use of a huge number of different engines, each only once or twice. This is due to class loading and JIT overhead.


h3. Usability

This goal has not been specifically addressed in the current design. However, the use of JavaCC to generate the expression parsers should lead to fairly good error messages when unsupported or erroneous expressions are encountered.


h3. Documentation

Use of JavaCC to generate the expression parsers leads to a fairly readable documentation of the supported (or, at least, parsed) expression syntax.

Test-driven development should ensure that all supported features are clearly documented and verified by tests. The infrastructure to add tests in a consistent way is not documented yet.


h3. Trustworthiness

AFC uses "JODE":-jode to decomile generated engines. This lets you have a look at the generated code in an understandable format. AFC takes great care to produce byte-code that is the equivalent of code produced by @javac@ from Java sources.

The tests, however, do not yet verify that the decompiled code, when run through @javac@ again, corresponds exactly to the bytecode produced by AFC.

