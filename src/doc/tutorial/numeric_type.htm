<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
	<meta http-equiv="Content-Type" content="text/html; charset=iso-8859-1" />
    <title>Numeric Types in SEJ - arrenbrecht.ch</title>
    <style type="text/css" media="screen">
        @import "../style.css";
	
    </style>
    <link rel="stylesheet" type="text/css" media="print" href="../printstyle.css" />
</head>
<body>
    <div class="all">
        <div class="nav">
            <p class="nav">
<a href="http://www.arrenbrecht.ch/">arrenbrecht.ch</a> &gt;
<a href="../index.htm">SEJ</a> &gt;
<a href="index.htm">Tutorial</a> &gt;

			</p>
        </div>
        <div class="title">
            <h1>
                Numeric Types in SEJ</h1>
        </div>
        
        
        <div class="content">
        
<p>Besides the default <tt>double</tt>, SEJ supports a number of alternative numeric types you can choose from for the computations performed by generated engines. This is because <tt>double</tt> is not precise enough for financial applications. The choices are:</p><dl><dt><a href="#double"><tt>double</tt></a></dt><dd>is the default. It is what Excel and other spreadsheet applications use internally. So this choice is consistent with how the original spreadsheet behaves.</dd><dt><a href="#BigDecimal"><tt>BigDecimal</tt></a></dt><dd>can be used with either its internal scaling, or using a fixed scale. With a fixed scale, this type is a good choice for financial applications which must be able to cope with very high values.</dd><dt><a href="#long"><tt>long</tt></a></dt><dd>can be used either as an integer type, or using a fixed scale. With a fixed scale of 4 decimal places, this type corresponds to the <tt>currency</tt> type found in Microsoft COM and Borland Delphi.</dd></dl>
<p>Note that the choice of numeric type <a href="#GlobalSetting">affects the entire engine</a> compiled by a given compiler, not just individual cells.</p>

<h2><a name="double">Using <tt>double</tt></a></h2>
<p>Since <tt>double</tt> is the default, you can simply use the default engine builder, without specifying the type. If you want to give the type explicitly, use:</p>
<p>[jc:sej.tutorials.UsingDouble:---- buildCompiler]</p>
<p>When using <tt>double</tt>, the natural type for our numeric inputs and outputs is, of course, <tt>double</tt> as well. Other types are <a href="type_conversion.htm">converted by SEJ</a> to a <tt>double</tt> prior to using them in the computation.</p>
<p>[jc:sej.tutorials.UsingDouble:---- IO]</p>
<p>In this example, we divide <em>InputA</em> by <em>InputB</em> and add <em>InputA</em>, ie. 1 + 1/6. The result is returned with <tt>double</tt>'s precision:</p>
<p>[jc:sej.tutorials.UsingDouble:---- checkResult]</p>

<h2><a name="BigDecimal">Using <tt>BigDecimal</tt></a></h2>
<p>As I explained before, <tt>BigDecimal</tt> can be used with an arbitrary, fixed scale and defined rounding mode. In this example, we choose greater precision than <tt>double</tt> offers (namely 20 decimals after the point) and always round up. We only need to change one line compared to the builder setup for the <a href="#double"><tt>double</tt> example</a>:</p>
<p>[jc:sej.tutorials.UsingBigDecimal:---- buildCompiler]</p>
<p>The natural type for our numeric inputs and outputs is now <tt>BigDecimal</tt>. Again, other types are <a href="type_conversion.htm">converted by SEJ</a> to a <tt>BigDecimal</tt> prior to using them in the computation.</p>
<p>[jc:sej.tutorials.UsingBigDecimal:---- IO]</p>
<p>We again compute 1 + 1/6. The result is returned with the increased precision we demanded, rounded up:</p>
<p>[jc:sej.tutorials.UsingBigDecimal:---- checkResult]</p>

<h3>Predefined <tt>BIGDECIMAL8</tt></h3>
<p>A good choice for financial applications is the predefined type <tt>BIGDECIMAL8</tt>. This type has a fixed scale of 8 and rounds halves up:</p>
<p>[jc:sej.tutorials.UsingBigDecimal:---- buildCompiler8]</p>
<p>We again compute 1 + 1/6. The result is returned with the defined 8 decimals after the point, rounded up since the last <tt>6</tt> is higher than a half:</p>
<p>[jc:sej.tutorials.UsingBigDecimal:---- checkResult8a]</p>
<p>If, instead, we compute 1 + 1/3, we get a result that is rounded down since the last <tt>3</tt> is less than a half:</p>
<p>[jc:sej.tutorials.UsingBigDecimal:---- checkResult8b]</p>

<h3>Unscaled <tt>BigDecimal</tt></h3>
<p>Let's use a <tt>BigDecimal</tt> without a fixed scale:</p>
<p>[jc:sej.tutorials.UsingBigDecimal:---- buildCompilerN]</p>
<p>With this beast, you have to be very careful about the computations your users specify in the spreadsheets. This is because <tt>BigDecimal</tt> will fail for non-representable fractions. The value of 1 + 1/4 can be computed ok:</p>
<p>[jc:sej.tutorials.UsingBigDecimal:---- checkResultNa]</p>
<p>But 1 + 1/3 does not have a finite decimal representation, so <tt>BigDecimal</tt> faults:</p>
<p>[jc:sej.tutorials.UsingBigDecimal:---- checkResultNb]</p>

<h2><a name="long">Using scaled <tt>long</tt></a></h2>
<p>The <tt>long</tt> type can be used either as an integer type, or in scaled mode. In scaled mode, it is still a long, but interpreted as if the <em>n</em> rightmost digits were decimal places. In this example, we choose 3 digits after the decimal point. Note that as of release 0.4.1, scaled long does not support rounding modes. It always truncates. Again, we only need to change one line compared to the builder setup for the <a href="#double"><tt>double</tt> example</a>:</p>
<p>[jc:sej.tutorials.UsingScaledLong:---- buildCompiler]</p>
<p>The natural type for our numeric inputs and outputs is now <tt>long</tt>. But we have a problem here: <tt>long</tt> is not normally scaled. So SEJ needs a way to differentiate between values that are normal, unscaled <tt>long</tt> values, and values that are scaled.</p>
<p>SEJ does not simply assume all <tt>long</tt> values to be scaled. This would be unexpected behaviour. And it would prohibit using the same interface for engines of different numeric types. For example, you could have a base interface you use for both scaled and unscaled <tt>long</tt> computations, which has a <tt>long getNumberOfItems()</tt> method.</p>
<p>There are two ways you can tell SEJ that a <tt>long</tt> is already scaled:</p>
<ul class="spaced">
<li>Use the annotation <tt>@ScaledLong</tt> on the input or output method.</li>
<li>Use the annotation <tt>@ScaledLong</tt> on the entire input or output type. This sets the default for all <tt>long</tt> return types of method of the type that don't override the scale themselves.</li>
</ul>
<p>The annotation controls the scale of the value obtained or returned by SEJ. This scale is independent of the scale SEJ uses for the internal computations. If the scales equal, then no <a href="type_conversion.htm">conversion</a> is needed. Otherwise SEJ rescales the values appropriately.</p>
<p>Since scaled long support depends on annotations, you cannot (I think) declare them in SEJ's Java 1.4 compatibility mode. But generated engines should run perfectly well on Java 1.4.</p>
<p>[jc:sej.tutorials.UsingScaledLong:---- IO]</p>
<p>We again compute 1 + 1/6. The result is a scaled <tt>long</tt> (so <tt>1166L</tt> is the scaled <tt>long</tt> equivalent of 1.166). We get 1.166 and not 1.167 because the scaled long always truncates results (this is how <tt>long</tt> itself works in Java):</p>
<p>[jc:sej.tutorials.UsingScaledLong:---- checkResult]</p>

<h3>Predefined <tt>LONG4</tt></h3>
<p>A good choice for financial applications is the predefined type <tt>LONG4</tt>. This type has a fixed scale of 4 and behaves much like the <em>currency</em> type found in Microsoft COM and Borland Delphi. To use it, we need to switch to a version of the output interface with proper scaling (<tt>Input4</tt> and <tt>Output4</tt> specify <tt>@ScaledLong(4)</tt>).</p>
<p>[jc:sej.tutorials.UsingScaledLong:---- buildCompiler4]</p>
<p>We again compute 1 + 1/6. The result is returned with the defined 4 decimals after the point, truncated:</p>
<p>[jc:sej.tutorials.UsingScaledLong:---- checkResult4]</p>

<h3>Unscaled <tt>long</tt></h3>
<p>Let's use a <tt>long</tt> without decimal places (<tt>Input0</tt> and <tt>Output0</tt> specify <tt>@ScaledLong(0)</tt>):</p>
<p>[jc:sej.tutorials.UsingScaledLong:---- buildCompiler0]</p>
<p>If we compute 1 + 1/6 here, we simply get 0:</p>
<p>[jc:sej.tutorials.UsingScaledLong:---- checkResult0]</p>

<h2><a name="GlobalSetting">Numeric Type Is A Global Setting</a></h2>
<p>Why is the numeric type set once per compiler, and not individually, per input or output cell? After all, consider a computation where we have as input the integer lengths of the three sides of a block in millimetres, and the price per millimetre cubed. We want the total price. So, typically:</p>
<pre>total := (width * height * depth) * price_per_mm3;</pre>

<p>Since all of the dimensions are integer, we might code this as:</p>
<pre>long width, height, depth;
BigDecimal total, price_per_mm3;</pre>

<p>This would ensure that the two multiplications computing the volume would run at <tt>long</tt>-speed. Is this correct? It depends. If you can be sure that the volume will always fit into the <tt>long</tt> range, then yes. But even if this were so, once you use SEJ to outsource this computation to a spreadsheet, you lose control over the exact way the computation is performed. It could, for instance, be changed by one user to:</p>
<pre>total := (width / 1000) * (height / 1000) * (depth / 1000) * price_per_m3;</pre>

<p>where <tt>price_per_m3</tt> is looked up in a table. What should SEJ choose as the data type for the intermediate divisions? Hmm.</p>
<p>An even simpler change, building a slight oversize into the computation, would be:</p>
<pre>total := ((width + 2) * (height + 2) * (depth + 2)) * price_per_mm3;</pre>

<p>So you - the programmer - may have been sure before that the volume would always fit into a <tt>long</tt>. But how can SEJ be sure that the slightly larger volume computed above will still fit? It cannot.</p>
<p>In view of these overflow and precision problems, SEJ does not try to be clever about inferring fast types. Every simple addition of input values already forces escalation to a bigger and slower type, so without hints from outside, SEJ would have to infer slow types for nearly everything very quickly. Who could give the hints? You, the programmer, cannot, because you do not know the computations performed by the sheets defined by users later on. So it would have to be the sheet designers. I cannot imagine them caring about and being able to specify overflow conditions.</p>
<p>What you can tell SEJ is the general class of computation you are dealing with. You simply specify the type being used for all numeric computations by a particular engine.</p>
<p>The responsibility for this choice, and for communicating its consequences to the sheet designers, rests fully with you, the programmer. But it does allow you to generate engines suited for precise financial or very fast pure integer computations.</p>        </div>
        <div class="footer">
<p>Copyright &copy; 2006 Peter Arrenbrecht. All rights reserved.
<br/>Last updated on 10.08.2006.</p>        </div>
    </div>
</body>
</html>