<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
	<meta http-equiv="Content-Type" content="text/html; charset=iso-8859-1" />
    <title>Numeric Types in SEJ - arrenbrecht.ch</title>
    <style type="text/css" media="screen">
        @import "../../style.css";
	
    </style>
    <link rel="stylesheet" type="text/css" media="print" href="../../printstyle.css" />
	
	<link rel="shortcut icon" href="../../favicon.ico" />
	<link rel="alternate" type="application/rss+xml" title="RSS" href="http://www.arrenbrecht.ch/sej/rss.xml" />
</head>
<body>
    <div class="all">
        <div class="nav">
            <p class="nav">
<a href="../../index.htm">arrenbrecht.ch</a> &gt;
<a href="../index.htm">SEJ</a> &gt;
<a href="index.htm">Tutorial</a> &gt;

			</p>
        </div>
        <div class="title">
            <p class="nofirefox">
                This site displays best on <a href="http://www.mozilla.com/">Firefox</a>.</p>
            <h1>
                Numeric Types in SEJ</h1>
        </div>
        
        
        <div class="content">
        
<p>Besides the default <tt>double</tt>, SEJ supports a number of alternative numeric types you can choose from for the computations performed by generated engines. This is because <tt>double</tt> is not precise enough for financial applications. The choices are:</p><dt><a href="#double"><tt>double</tt></a></dt><dd>is the default. It is what Excel and other spreadsheet applications use internally, so this choice is consistent with how the original spreadsheet behaves.</dd><dt><a href="#BigDecimal"><tt>BigDecimal</tt></a></dt><dd>can be used with either its internal scaling, or using a fixed scale. With a fixed scale, this type is a good choice for financial applications which must be able to cope with very high values.</dd><dt><tt>long</tt></dt><dd>can be used either as an integer type, or using a fixed scale. With a fixed scale of 4 decimal places, this type corresponds to the <tt>currency</tt> type found in Microsoft COM and Borland Delphi.
<br/><em>Support for <tt>long</tt> is not implemented yet!</em></dd>

<h2><a name="double">Using <tt>double</tt></a></h2>
<p>Since <tt>double</tt> is the default, you can simply use the default compiler constructor, without specifying the type. If you want to give the type explicitly, call:</p>
<pre class="java">Spreadsheet sheet = SpreadsheetLoader.loadFromFile<span class="j-sym">( </span>path <span class="j-sym">)</span>;
Class inp = Input.<span class="j-key">class</span>;
Class outp = Output.<span class="j-key">class</span>;
NumericType type = <span class="j-hl">NumericType.DOUBLE</span>;
Compiler compiler = CompilerFactory.newDefaultCompiler<span class="j-sym">( </span>sheet, inp, outp, type <span class="j-sym">)</span>;</pre>
<p>When using <tt>double</tt>, all our numeric inputs and outputs must be declared as <tt>double</tt> as well:</p>
<pre class="java"><span class="j-key">public static class </span>Input
<span class="j-sym">{
  </span><span class="j-key">public </span><span class="j-hl">double</span> getA<span class="j-sym">() { </span><span class="j-key">return </span><span class="j-num">1.0</span>; <span class="j-sym">}
  </span><span class="j-key">public </span><span class="j-hl">double</span> getB<span class="j-sym">() { </span><span class="j-key">return </span><span class="j-num">6.0</span>; <span class="j-sym">}
}

</span><span class="j-key">public static interface </span>Output
<span class="j-sym">{
  </span><span class="j-hl">double</span> getResult<span class="j-sym">()</span>;
<span class="j-sym">}</span></pre>
<p>In this example, we divide <em>InputA</em> by <em>InputB</em>, ie. <tt>1/6</tt>. The result is returned with <tt>double</tt>'s precision:</p>
<pre class="java">Input i = <span class="j-key">new </span>Input<span class="j-sym">()</span>;
Output o = <span class="j-sym">(</span>Output<span class="j-sym">) </span>engine.newComputation<span class="j-sym">( </span>i <span class="j-sym">)</span>;
assertEquals<span class="j-sym">( </span><span class="j-hl"><span class="j-str">&#34;0.16666666666666666&#34;</span></span>, String.valueOf<span class="j-sym">( </span>o.getResult<span class="j-sym">()) )</span>;</pre>

<h2><a name="BigDecimal">Using <tt>BigDecimal</tt></a></h2>
<p>As I explained before, <tt>BigDecimal</tt> can be used with an arbitrary, fixed scale and defined rounding mode. In this example, we choose greater precision than <tt>double</tt> offers (namely 20 decimals after the point) and always round up:</p>
<pre class="java">NumericType type = <span class="j-hl">NumericType.getInstance<span class="j-sym">( </span>BigDecimal.class, <span class="j-num">20</span>, BigDecimal.ROUND_UP <span class="j-sym">)</span></span>;
Compiler compiler = CompilerFactory.newDefaultCompiler<span class="j-sym">( </span>sheet, inp, outp, type <span class="j-sym">)</span>;</pre>
<p>All our numeric inputs and outputs must now be declared as <tt>BigDecimal</tt>:</p>
<pre class="java"><span class="j-key">public static class </span>Input
<span class="j-sym">{
  </span><span class="j-key">public </span>Input<span class="j-sym">(</span><span class="j-typ">int </span>b<span class="j-sym">)  { </span><span class="j-key">this</span>.b = b; <span class="j-sym">}
  </span><span class="j-key">public </span><span class="j-hl">BigDecimal</span> getA<span class="j-sym">()  { </span><span class="j-key">return </span>BigDecimal.valueOf<span class="j-sym">( </span><span class="j-num">1 </span><span class="j-sym">)</span>; <span class="j-sym">}
  </span><span class="j-key">public </span><span class="j-hl">BigDecimal</span> getB<span class="j-sym">()  { </span><span class="j-key">return </span>BigDecimal.valueOf<span class="j-sym">( </span><span class="j-key">this</span>.b <span class="j-sym">)</span>; <span class="j-sym">}
  </span><span class="j-key">private final </span><span class="j-typ">int </span>b;
<span class="j-sym">}

</span><span class="j-key">public static interface </span>Output
<span class="j-sym">{
  </span><span class="j-hl">BigDecimal</span> getResult<span class="j-sym">()</span>;
<span class="j-sym">}</span></pre>
<p>We again compute <tt>1/6</tt>. The result is returned with the increased precision we demanded, rounded up:</p>
<pre class="java">Input i = <span class="j-key">new </span>Input<span class="j-sym">( </span><span class="j-num">6 </span><span class="j-sym">)</span>;
Output o = <span class="j-sym">(</span>Output<span class="j-sym">) </span>engine.newComputation<span class="j-sym">( </span>i <span class="j-sym">)</span>;
assertEquals<span class="j-sym">( </span><span class="j-hl"><span class="j-str">&#34;0.16666666666666666667&#34;</span></span>, o.getResult<span class="j-sym">()</span>.toPlainString<span class="j-sym">() )</span>;</pre>

<h3>Predefined <tt>BIGDECIMAL8</tt></h3>
<p>A good choice for financial applications is the predefined type <tt>BIGDECIMAL8</tt>. This type has a fixed scale of 8 and rounds halves up:</p>
<pre class="java">NumericType type = <span class="j-hl">NumericType.BIGDECIMAL8</span>;
Compiler compiler = CompilerFactory.newDefaultCompiler<span class="j-sym">( </span>sheet, inp, outp, type <span class="j-sym">)</span>;</pre>
<p>We again compute <tt>1/6</tt>. The result is returned with the defined 8 decimals after the point, rounded up since the last <tt>6</tt> is higher than a half:</p>
<pre class="java">Input i = <span class="j-key">new </span>Input<span class="j-sym">( </span><span class="j-num">6 </span><span class="j-sym">)</span>;
Output o = <span class="j-sym">(</span>Output<span class="j-sym">) </span>engine.newComputation<span class="j-sym">( </span>i <span class="j-sym">)</span>;
assertEquals<span class="j-sym">( </span><span class="j-hl"><span class="j-str">&#34;0.16666667&#34;</span></span>, o.getResult<span class="j-sym">()</span>.toPlainString<span class="j-sym">() )</span>;</pre>
<p>If, instead, we compute <tt>1/3</tt>, we get a result that is rounded down since the last <tt>3</tt> is less than a half:</p>
<pre class="java">Input i = <span class="j-key">new </span>Input<span class="j-sym">( </span><span class="j-hl">3</span> <span class="j-sym">)</span>;
Output o = <span class="j-sym">(</span>Output<span class="j-sym">) </span>engine.newComputation<span class="j-sym">( </span>i <span class="j-sym">)</span>;
assertEquals<span class="j-sym">( </span><span class="j-hl"><span class="j-str">&#34;0.33333333&#34;</span></span>, o.getResult<span class="j-sym">()</span>.toPlainString<span class="j-sym">() )</span>;</pre>

<h3>Unscaled <tt>BigDecimal</tt></h3>
<p>Let's use a <tt>BigDecimal</tt> without a fixed scale:</p>
<pre class="java">NumericType type = <span class="j-hl">NumericType.getInstance<span class="j-sym">( </span>BigDecimal.<span class="j-key">class </span><span class="j-sym">)</span>;</span>
Compiler compiler = CompilerFactory.newDefaultCompiler<span class="j-sym">( </span>sheet, inp, outp, type <span class="j-sym">)</span>;</pre>
<p>With this beast, you have to be very careful about the computations your users specify in the spreadsheets. This is because <tt>BigDecimal</tt> will fail for non-representable fractions. The value of <tt>1/4</tt> can be computed ok:</p>
<pre class="java">Input i = <span class="j-key">new </span>Input<span class="j-sym">( </span><span class="j-num">4 </span><span class="j-sym">)</span>;
Output o = <span class="j-sym">(</span>Output<span class="j-sym">) </span>engine.newComputation<span class="j-sym">( </span>i <span class="j-sym">)</span>;
assertEquals<span class="j-sym">( </span><span class="j-hl"><span class="j-str">&#34;0.25&#34;</span></span>, o.getResult<span class="j-sym">()</span>.toPlainString<span class="j-sym">() )</span>;</pre>
<p>But <tt>1/3</tt> does not have a finite decimal representation, so <tt>BigDecimal</tt> faults:</p>
<pre class="java"><span class="j-key">try </span><span class="j-sym">{
  </span>Input i = <span class="j-key">new </span>Input<span class="j-sym">( </span><span class="j-hl">3</span> <span class="j-sym">)</span>;
  Output o = <span class="j-sym">(</span>Output<span class="j-sym">) </span>engine.newComputation<span class="j-sym">( </span>i <span class="j-sym">)</span>;
  o.getResult<span class="j-sym">()</span>;
  fail<span class="j-sym">( </span><span class="j-str">&#34;ArithmeticException expected&#34; </span><span class="j-sym">)</span>;
<span class="j-sym">}
</span><span class="j-key">catch </span><span class="j-sym">(</span><span class="j-hl">ArithmeticException e</span><span class="j-sym">) {
  </span>assertEquals<span class="j-sym">( </span><span class="j-str">&#34;Non-terminating decimal expansion; no exact representable decimal result.&#34;</span>, e.getMessage<span class="j-sym">() )</span>;
<span class="j-sym">}</span></pre>        </div>
        <div class="footer">
<p>Copyright &copy; 2006 Peter Arrenbrecht. All rights reserved.
<br/>Last updated on 10.05.2006.</p>        </div>
    </div>
</body>
</html>