<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
	<meta http-equiv="Content-Type" content="text/html; charset=iso-8859-1" />
    <title>Binding Data in SEJ - arrenbrecht.ch</title>
    <style type="text/css" media="screen">
        @import "../style.css";
	
    </style>
    <link rel="stylesheet" type="text/css" media="print" href="../printstyle.css" />
</head>
<body>
    <div class="all">
        <div class="nav">
            <p class="nav">
<a href="http://www.arrenbrecht.ch/">arrenbrecht.ch</a> &gt;
<a href="../index.htm">SEJ</a> &gt;
<a href="index.htm">Tutorial</a> &gt;

			</p>
        </div>
        <div class="title">
            <h1>
                Binding Data in SEJ</h1>
        </div>
        
        
        <div class="content">
        
<p><span class="when">Note: All the sample code in this document has been cited by <a href="http://www.arrenbrecht.ch/jcite/">JCite</a> from source code that is checked for syntactic correctness during release builds. It is not yet in the form of tests, so semantic correctness is not ensured yet.</span></p><dt><a href="#BindCells">Binding Cells</a></dt><dd>Input and output cells of a spreadsheet are bound to methods of plain Java interfaces or classes.</dd><dt><a href="#BindByName">Binding Data By Name</a></dt><dd>If you have a generic system where the set of possible input values cannot be determined at compile-time, you have to resort to some sort of late binding, or binding by name.</dd><dt><a href="#BindMultipleInterfaces">Binding To Multiple Interfaces</a></dt><dd>SEJ allows you to set only a single interface to provide inputs to or obtain outputs from a computation. How can you work around this?</dd><dt><a href="#BindMultipleInstances">Binding To Multiple Instances</a></dt><dd>What if you need to provide multiple separate instances of source interfaces as input providers, or need SEJ to implement multiple separate instances of output interfaces?</dd><dt><a href="#BindRepeatingSections">Repeating Sections</a></dt><dd>How to define sections of a spreadsheet where the number of rows or columns is variable.</dd>

<h2><a name="BindCells">Binding Cells</a></h2>
<p>Input and output cells of a computation defined through a spreadsheet are bound to methods of plain Java interfaces or classes.</p>

<h3>Inputs</h3>
<p>To bind spreadsheet cells to variable input values, you must have an interface or a class defining getters for your input values. This is typically a public static inner type, defined explicitly for this purpose:</p>
<p>[jc:sej.tutorials.BindingCells:---- Input]</p>
<p>In order for the interface to be accessible to the generated engine, it must be <tt>public</tt>. This is because the engine is not loaded by the same class loader as your own classes (read <a href="http://www.artima.com/insidejvm/ed2/security2.html">why this matters</a>).</p>
<p>This type you provide to the engine builder prior to using it:</p>
<p>[jc:sej.tutorials.BindingCells:---- setupBuilder; highlight -in-; strip -out-]</p>
<p>In the <a href="basics.htm">simple usage scenario</a>, SEJ did all the cell binding automatically for you. Now you want to get full control over binding. To do this, you access the loaded spreadsheet, and the so called <em>root section binder</em>. This interface controls the binding of cells for the entire spreadsheet (as opposed to contained <a href="#BindRepeatingSections">sections of variable extent</a>).</p>
<p>[jc:sej.tutorials.BindingCells:---- getBinder]</p>
<p>You then tell the binder which cells are input cells, and to which getter methods on your type to bind them:</p>
<p>[jc:sej.tutorials.BindingCells:---- bindPlainInputs]</p>
<p>You can also bind to parametrized methods. The arguments to the method are, however, determined at compile-time of the engine. This is where the <tt>CallFrame</tt> comes into play:</p>
<p>[jc:sej.tutorials.BindingCells:---- bindParamInputs]</p>
<p>With the call frame, you can even chain calls. In this example, we do the equivalent of <tt>getName().length()</tt>, where <tt>getName()</tt> returns a <tt>String</tt>:</p>
<p>[jc:sej.tutorials.BindingCells:---- bindChainedInputs]</p>

<h3>Outputs</h3>
<p>Outputs that the spreadsheet computes are bound to methods of an interface or a dedicated abstract class you define. This type is implemented or subclassed by the generated computation engine, which overrides all methods bound to output cells so they perform the computation specified in the spreadsheet.</p>
<p>Your output type is typically a static inner type. In order for it to be accessible to the generated computation, it must be <tt>public</tt>.</p>
<p>[jc:sej.tutorials.BindingCells:---- Output]</p>
<p>Like the input type, you also provide to the engine builder prior to using it:</p>
<p>[jc:sej.tutorials.BindingCells:---- setupBuilder; highlight -out-; strip -in-]</p>
<p>Now that the type is in place, we can bind output cells to it:</p>
<p>[jc:sej.tutorials.BindingCells:---- bindPlainOutputs]</p>

<h3>Defaults</h3>
<p>If you supply implementations for your output methods, they serve as defaults in case they are not bound to an output cell of the spreadsheet. This is mainly useful when outputs are bound generically (by cell name, for instance).</p>
<p>To access input values when computing default output values, you can define a constructor that takes the input type as its sole parameter. SEJ then automatically calls that constructor with the current inputs. You can also access other output values by calling their corresponding methods, of course.</p>
<p>[jc:sej.tutorials.BindingCells:---- OutputWithDefaults]</p>

<h2><a name="BindByName">Binding By Name</a></h2>

<h3>Inputs</h3>
<p>If you have a generic system where the set of possible input values cannot be determined at compile-time, you have to resort to some sort of late binding, or binding by name. You can achieve this by binding cells to parametrized calls to a single dispatch method (or multiple ones - it's your choice). The input interface might be:</p>
<p>[jc:sej.tutorials.BindingByName:---- Input]</p>
<p>With this interface, you could, for instance, bind cells by name as follows:</p>
<p>[jc:sej.tutorials.BindingByName:---- bindNamedInputs]</p>
<p>In the implementation of <tt>getInput(String)</tt> you are free to look up the actual value of the named input in any way that seems fit. Like this, for example:</p>
<p>[jc:sej.tutorials.BindingByName:---- InputSample]</p>

<h3>Outputs</h3>
<p>To bind output values by name, you use an analogous construct:</p>
<p>[jc:sej.tutorials.BindingByName:---- Output]</p>
<p>and:</p>
<p>[jc:sej.tutorials.BindingByName:---- bindNamedOutputs]</p>
<p>Here's how you would use the generated engine:</p>
<p>[jc:sej.tutorials.BindingByName:---- checkResults]</p>
<p>SEJ must generate code that implements this by-name lookup for you to make this work. Here's how SEJ goes about it, assuming the spreadsheet contained two cells named <em>O_ONETWOTHREE</em> and <em>O_SUMINTER</em>:</p>
<p>[jc:sej.tutorials.BindingByName:---- GeneratedGetter]</p>
<p>The example shows why we must supply a default implementation for <tt>getResult(String)</tt>.</p>

<h3>Complex Outputs</h3>
<p>This not only works for index types that properly implement <tt>equals()</tt>, but also for the native types <tt>int</tt> and <tt>long</tt>. When the parameter is a native type, SEJ uses the <tt>==</tt> operator to compare the values. When there are multiple parameters, SEJ generates comparisons for all of the supplied values, joined by <tt>&&</tt>. The complex output method:</p>
<p>[jc:sej.tutorials.BindingByName:---- ComplexOutput]</p>
<p>is bound and then called as follows:</p>
<p>[jc:sej.tutorials.BindingByName:---- bindComplexOutput]</p>
<p>[jc:sej.tutorials.BindingByName:---- checkComplexResults]</p>
<p>Again, this is code similar to what SEJ generates in this situation:</p>
<p>[jc:sej.tutorials.BindingByName:---- GeneratedComplexGetter]</p>

<h5>Note</h5>
<p>Why does SEJ provide such black-box magic here when, for the inputs, it was stated as an explicit design goal to avoid such things? Well, providing the outputs is what SEJ <em>does</em>. So the implementation of the output interface must be SEJ's responsibility. We could have chosen an implementation where you could register multiple output interfaces, each with a distinct string name. You might then bind output cells to such a named interface. However, to access the named interface on a computation, there would again have to be a by-name lookup:</p>
<pre>Computation c = engine.newComputation();
Output o = (Output) c.getNamedOutput( "SomeOutput" );
double v = o.getValue();</pre>

<p>So we gain nothing but lose the close duality of how the input and output definitions work.</p>

<h2><a name="BindMultipleInterfaces">Multiple Interfaces</a></h2>
<p>SEJ allows you to set only a single interface to provide inputs to or obtain outputs from a computation. How can you work around this?</p>

<h3>Inputs</h3>
<p>To feed information to a computation from various sources, each with its own interface, you need to define a wrapper that gives access to the source interfaces.</p>
<p>Consider these two source interfaces:</p>
<p>[jc:sej.tutorials.BindingToMultipleInterfaces:---- Inputs]</p>
<p>The wrapper is a class with accessor properties returning instances the two source interfaces:</p>
<p>[jc:sej.tutorials.BindingToMultipleInterfaces:---- Input]</p>
<p>You then bind cells to elements of a particular source interface by using a <em>call chain</em>. SEJ allows you to bind cells to the result of calling a chain of methods:</p>
<p>[jc:sej.tutorials.BindingToMultipleInterfaces:---- bindInputs]</p>

<h5>Note</h5>
<p>SEJ does not support multiple input interfaces directly because this would add a part of the application logic to SEJ that does not need to be customizable by spreadsheets. Therefore, it is better to leave this logic outside of SEJ. This gives you full control over it and avoids adding more black box behaviour than necessary.</p>

<h3>Outputs</h3>
<p>Assume a computation in a sheet must supply output values for two different interfaces:</p>
<p>[jc:sej.tutorials.BindingToMultipleInterfaces:---- Outputs]</p>
<p>To achieve this, the simplest approach is to simply make your output class implement both of the target interfaces:</p>
<p>[jc:sej.tutorials.BindingToMultipleInterfaces:---- Output]</p>
<p>You can then use your computation's output with both targets. However, this only works if name clashes are acceptable, that is, <tt>OutputA.getResult()</tt> maps to the same spreadsheet cell as <tt>OutputB.getResult()</tt>.</p>

<h5>Disambiguation</h5>
<p>If this is not the case, you have to do a little more work. You define your output class as follows:</p>
<p>[jc:sej.tutorials.BindingToMultipleInterfaces:---- Output2]</p>
<p>Then, you define wrappers which implement the proper interfaces:</p>
<p>[jc:sej.tutorials.BindingToMultipleInterfaces:---- Output2A]</p>
<p>and</p>
<p>[jc:sej.tutorials.BindingToMultipleInterfaces:---- Output2B]</p>

<h5>Note</h5>
<p>SEJ does not support the following idiom:</p>
<p>[jc:sej.tutorials.BindingToMultipleInterfaces:---- Output3]</p>
<p>as it did for inputs. This is because for outputs, it is SEJ's responsibility to implement this interface. It only supports the approach with the least black box magic.</p>

<h2><a name="BindMultipleInstances">Multiple Interface Instances</a></h2>
<p>What if you need to provide multiple separate instances of source interfaces as input providers, or need SEJ to implement multiple separate instances of output interfaces?</p>

<h3>Inputs</h3>
<p>Let's assume you have <em>n</em> separate customer categories. You want to bind all cells named after the pattern <em>CC_DISCOUNT_&lt;n&gt;</em> to the discount percentage associated with the customer category <em>&lt;n&gt;</em>. Here's how you go about it.</p>
<p>Let's assume the following customer interface:</p>
<p>[jc:sej.tutorials.BindingToMultipleInstances:---- CC]</p>
<p>First, you define an accessor for the customer categories on the main input interface:</p>
<p>[jc:sej.tutorials.BindingToMultipleInstances:---- Input]</p>
<p>Then, you bind input cells in a loop. The key is to use a call chain that supplies the proper index argument to the customer category accessor:</p>
<p>[jc:sej.tutorials.BindingToMultipleInstances:---- bindInputs]</p>

<h3>Outputs</h3>
<p>Let's assume a spreadsheet is used to update next year's discount percentage and credit limit for each customer category based on this year's input. The sheet computes the outputs for all of the categories simultaneously because there may be dependencies between the categories. As above, the number of categories is not fixed at compile-time. You cannot use bands to model this sheet because you do not want to force the user to use the same computation model for every category.</p>
<p>The input model for this sheet can be implemented as described above. How do you specify the outputs? You have to use parametrized accessors for each value separately:</p>
<p>[jc:sej.tutorials.BindingToMultipleInstances:---- Output]</p>
<p>which you bind as follows:</p>
<p>[jc:sej.tutorials.BindingToMultipleInstances:---- bindOutputs]</p>
<p>You might think that the following interface definition would be much nicer:</p>
<p>[jc:sej.tutorials.BindingToMultipleInstances:---- Output2]</p>
<p>I agree. Unfortunately, SEJ does not directly support it (again a consequence of keeping the black box magic in SEJ at a minimum). You are, however, free to put such a façade on top of the original interface:</p>
<p>[jc:sej.tutorials.BindingToMultipleInstances:---- OutputFacade]</p>
<p>You might for example need to do this if you have to feed the sheet's output to some other system that expects its input in the above form. The façade would then have to implement the other system's input interfaces, of course.</p>

<h2><a name="BindRepeatingSections">Repeating Sections</a></h2>
<p>SEJ allows you to define repeating sections in spreadsheets. Examples would be</p>
<ul compact class="compact">
<li>all order totals of the last three months for this customer,</li>
<li>all employees for which bonuses must be computed given a total bonus amount.</li>
</ul>

<h3>Input-only</h3>
<p>The first example provides only input to some computation. To tell SEJ how many and which order totals there are, you need an input interface method with an <tt>Iterable</tt> or <tt>array</tt> result:</p>
<p>[jc:sej.tutorials.BindingRepeatingSections:---- Input]</p>
<p>Then you define the section and bind it to the input method. You also supply the type to be used to access section elements. The method returns another section binder (like the root binder we've been using up to now), which you use to bind cells and subsections of the section:</p>
<p>[jc:sej.tutorials.BindingRepeatingSections:---- bindInputSection]</p>
<p>Within the section, you bind the input cell for the order total:</p>
<p>[jc:sej.tutorials.BindingRepeatingSections:---- bindInputCell]</p>

<h3>Input/Output</h3>
<p>In the second example above, you are also interested in output values that are repeated. The input is structured as it was for pure inputs:</p>
<p>[jc:sej.tutorials.BindingRepeatingSections:---- Input2]</p>
<p>To define the outputs for each employee, your output interface must have a corresponding method returning an appropriate <tt>Iterable</tt>:</p>
<p>[jc:sej.tutorials.BindingRepeatingSections:---- Output]</p>
<p>With this definition you can write:</p>
<p>[jc:sej.tutorials.BindingRepeatingSections:---- bindIOSection]</p>
<p>This binds the repeating section to the output as well as the input specification, allowing:</p>
<p>[jc:sej.tutorials.BindingRepeatingSections:---- bindOutputCell]</p>
<p>With this, SEJ is going to implement the iterator as well as the computation of employee outputs for you. Behind the scenes, it generates descendants of both <tt>Output</tt> and <tt>Output.Employee</tt> for this.</p>        </div>
        <div class="footer">
<p>Copyright &copy; 2006 Peter Arrenbrecht. All rights reserved.
<br/>Last updated on 28.06.2006.</p>        </div>
    </div>
</body>
</html>