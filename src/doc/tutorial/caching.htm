<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
	<meta http-equiv="Content-Type" content="text/html; charset=iso-8859-1" />
    <title>Caching Of Values in SEJ - arrenbrecht.ch</title>
    <style type="text/css" media="screen">
        @import "../../style.css";
	
    </style>
    <link rel="stylesheet" type="text/css" media="print" href="../../printstyle.css" />
	
	<link rel="shortcut icon" href="../../favicon.ico" />
	<link rel="alternate" type="application/rss+xml" title="RSS" href="http://www.arrenbrecht.ch/sej/rss.xml" />
</head>
<body>
    <div class="all">
        <div class="nav">
            <p class="nav">
<a href="../../index.htm">arrenbrecht.ch</a> &gt;
<a href="../index.htm">SEJ</a> &gt;
<a href="index.htm">Tutorial</a> &gt;

			</p>
        </div>
        <div class="title">
            <p class="nofirefox">
                This site displays best on <a href="http://www.mozilla.com/">Firefox</a>.</p>
            <h1>
                Caching Of Values in SEJ</h1>
        </div>
        
        
        <div class="content">
        
<p>Consider the following example spreadsheet doing the computation of a square's area and a cube's volume, given the side length. The cell B1 is the sole input, B2 and B3 are outputs.</p>
<pre>   A        B
1  Side     2
2  Area     =B1*B1
3  Volume   =B2*B1</pre>

<p>As you can see, the area is reused by the volume computation. This is, of course, a very simple example. But even here, if we were to compute millions of areas and volumes using <tt>BigDecimal</tt> and side lengths of great precision, it might already pay off to cache the intermediate value for the area.</p>
<p>Also, the value for side is used three times in all. Assuming it is expensive to obtain the side length (maybe it involves a database access), it might also pay off to cache this value. This value could of course be cached by the application itself. However, since SEJ supports automatic internal caching anyway, it also relieves you of the tedium of manually caching input values.</p>
<p>Finally, SEJ also caches output values, just in case you want to access them multiple times, without having to cache them yourself.</p>

<h5>Note</h5>
<p>Caching of input values also encourages a functional view of computations, i.e. input value accessors that have no side effects. Since you cannot know beforehand how many times a spreadsheet will access your input values, having side effects in them is very likely a bad idea.</p>

<h2>Default Is No Caching</h2>
<p>Normally, computations generated by SEJ do not cache values internally - they are essentially stateless. This ensures that they behave correctly when you call a computation multiple times while, in between, modifying the data returned by its input object. Here is an example of this:</p>
<pre class="java">Input input = <span class="j-key">new </span>Input<span class="j-sym">()</span>;
PlainOutput output = <span class="j-sym">(</span>PlainOutput<span class="j-sym">) </span>engine.newComputation<span class="j-sym">( </span>input <span class="j-sym">)</span>;

input.setSide<span class="j-sym">( </span><span class="j-hl"><span class="j-str">&#34;10&#34;</span></span><span class="j-sym">)</span>;
assertEquals<span class="j-sym">( </span><span class="j-hl"><span class="j-str">&#34;100&#34;</span></span>, output.getArea<span class="j-sym">()</span>.toPlainString<span class="j-sym">() )</span>;
assertEquals<span class="j-sym">( </span><span class="j-hl"><span class="j-str">&#34;1000&#34;</span></span>, output.getVolume<span class="j-sym">()</span>.toPlainString<span class="j-sym">() )</span>;

input.setSide<span class="j-sym">( </span><span class="j-hl"><span class="j-str">&#34;5&#34;</span></span><span class="j-sym">)</span>;
assertEquals<span class="j-sym">( </span><span class="j-hl"><span class="j-str">&#34;25&#34;</span></span>, output.getArea<span class="j-sym">()</span>.toPlainString<span class="j-sym">() )</span>;
assertEquals<span class="j-sym">( </span><span class="j-hl"><span class="j-str">&#34;125&#34;</span></span>, output.getVolume<span class="j-sym">()</span>.toPlainString<span class="j-sym">() )</span>;</pre>
<p>The generated computation looks essentially like this:</p>
<pre class="java"><span class="j-key">private </span>BigDecimal getSide<span class="j-sym">()   { </span><span class="j-key">return this</span>.input.getSide<span class="j-sym">()</span>; <span class="j-sym">}
</span><span class="j-key">public </span>BigDecimal getArea<span class="j-sym">()    { </span><span class="j-key">return </span>getSide<span class="j-sym">()</span>.multiply<span class="j-sym">( </span>getSide<span class="j-sym">() )</span>; <span class="j-sym">}
</span><span class="j-key">public </span>BigDecimal getVolume<span class="j-sym">()  { </span><span class="j-key">return </span>getArea<span class="j-sym">()</span>.multiply<span class="j-sym">( </span>getSide<span class="j-sym">() )</span>; <span class="j-sym">}</span></pre>

<h2>Turning On Caching</h2>
<p>Once a computation starts doing internal caching, that is, once it starts to have state, there must be a way for you to control that state. In particular, you have to be able to <em>reset</em> a computation when you have modified its input. Therefore, SEJ only uses internal caching if your output interface or class implements the <tt>Resettable</tt> interface:</p>
<pre class="java"><span class="j-jdoc">/**
 * Interface that must be implemented by an output class (or extended by an output interface) of
 * computations that need internal caching of values.
 * 
 * </span><span class="j-jdoc-key">@author </span><span class="j-jdoc">peo
 */
</span><span class="j-key">public interface </span>Resettable
<span class="j-sym">{

  </span><span class="j-jdoc">/**
   * Clears all internal caches of the computation so it can be reused with changed input values.
   * You do not need to implement this method yourself. As long as you declare it, SEJ will
   * implement it for you. If you do implement it, SEJ will call it prior to resetting the
   * computation.
   */
  </span><span class="j-typ">void </span>reset<span class="j-sym">()</span>;

<span class="j-sym">}</span></pre>
<p>Let's do this now:</p>
<pre class="java"><span class="j-key">public static interface </span>CachingOutput <span class="j-hl">extends Resettable</span>
<span class="j-sym">{
  </span>BigDecimal getArea<span class="j-sym">()</span>;
  BigDecimal getVolume<span class="j-sym">()</span>;
<span class="j-sym">}</span></pre>
<p>Compiling an engine with this output interface turns caching on. Here's what happens if we run the above example again:</p>
<pre class="java">Input input = <span class="j-key">new </span>Input<span class="j-sym">()</span>;
CachingOutput output = <span class="j-sym">(</span>CachingOutput<span class="j-sym">) </span>engine.newComputation<span class="j-sym">( </span>input <span class="j-sym">)</span>;

input.setSide<span class="j-sym">( </span><span class="j-str">&#34;10&#34; </span><span class="j-sym">)</span>;
assertEquals<span class="j-sym">( </span><span class="j-str">&#34;100&#34;</span>, output.getArea<span class="j-sym">()</span>.toPlainString<span class="j-sym">() )</span>;
assertEquals<span class="j-sym">( </span><span class="j-str">&#34;1000&#34;</span>, output.getVolume<span class="j-sym">()</span>.toPlainString<span class="j-sym">() )</span>;

input.setSide<span class="j-sym">( </span><span class="j-str">&#34;5&#34; </span><span class="j-sym">)</span>;
assertEquals<span class="j-sym">( </span><span class="j-hl"><span class="j-str">&#34;100&#34;</span></span>, output.getArea<span class="j-sym">()</span>.toPlainString<span class="j-sym">() )</span>;
assertEquals<span class="j-sym">( </span><span class="j-hl"><span class="j-str">&#34;1000&#34;</span></span>, output.getVolume<span class="j-sym">()</span>.toPlainString<span class="j-sym">() )</span>;</pre>
<p>Note how changing the input value does <b>not</b> affect the output values. This is because they are already cached from the previous access. To correct this, we have to call <tt>reset()</tt>, which SEJ implemented for us:</p>
<pre class="java">input.setSide<span class="j-sym">( </span><span class="j-str">&#34;5&#34; </span><span class="j-sym">)</span>;
<span class="j-hl">output.reset<span class="j-sym">()</span>;</span>
assertEquals<span class="j-sym">( </span><span class="j-hl"><span class="j-str">&#34;25&#34;</span></span>, output.getArea<span class="j-sym">()</span>.toPlainString<span class="j-sym">() )</span>;
assertEquals<span class="j-sym">( </span><span class="j-hl"><span class="j-str">&#34;125&#34;</span></span>, output.getVolume<span class="j-sym">()</span>.toPlainString<span class="j-sym">() )</span>;</pre>

<h5>Was it worth it?</h5>
<p>In this example, did caching pay off? We look at the simple case of just computing the area and volume once:</p>
<pre class="java"><span class="j-typ">long </span>startTime = System.nanoTime<span class="j-sym">()</span>; 
output.getArea<span class="j-sym">()</span>;
output.getVolume<span class="j-sym">()</span>;
<span class="j-typ">long </span>endTime = System.nanoTime<span class="j-sym">()</span>;
<span class="j-key">return </span>endTime - startTime;</pre>
<p>We do this for both versions and find - that caching is more than twice as fast!</p>
<pre class="java">input.setSide<span class="j-sym">( </span><span class="j-str">&#34;123456789123456789&#34; </span><span class="j-sym">)</span>;
<span class="j-typ">long </span>plainTime = time<span class="j-sym">( </span>plainEngine, input <span class="j-sym">)</span>;
<span class="j-typ">long </span>cachingTime = time<span class="j-sym">( </span>cachingEngine, input <span class="j-sym">)</span>;
assertTrue<span class="j-sym">( </span><span class="j-str">&#34;Caching is at least twice as fast&#34;</span>, cachingTime * <span class="j-num">2 </span>&lt; plainTime <span class="j-sym">)</span>;</pre>

<h2>Caching Internals</h2>
<p>The generated caching computation looks essentially like this:</p>
<pre class="java"><span class="j-key">private </span><span class="j-typ">boolean </span>haveSide;
<span class="j-key">private </span>BigDecimal cacheSide;
<span class="j-key">private </span>BigDecimal getSide<span class="j-sym">()
{
  </span><span class="j-key">if </span><span class="j-sym">(</span>!<span class="j-key">this</span>.haveSide<span class="j-sym">) {
    </span><span class="j-key">this</span>.cacheSide = <span class="j-key">this</span>.input.getSide<span class="j-sym">()</span>;
    <span class="j-key">this</span>.haveSide = <span class="j-key">true</span>;
  <span class="j-sym">}
  </span><span class="j-key">return this</span>.cacheSide;
<span class="j-sym">}

</span><span class="j-key">private </span><span class="j-typ">boolean </span>haveArea;
<span class="j-key">private </span>BigDecimal cacheArea;
<span class="j-key">public </span>BigDecimal getArea<span class="j-sym">()
{
  </span><span class="j-key">if </span><span class="j-sym">(</span>!<span class="j-key">this</span>.haveArea<span class="j-sym">) {
    </span><span class="j-key">this</span>.cacheArea = getSide<span class="j-sym">()</span>.multiply<span class="j-sym">( </span>getSide<span class="j-sym">() )</span>;
    <span class="j-key">this</span>.haveArea = <span class="j-key">true</span>;
  <span class="j-sym">}
  </span><span class="j-key">return this</span>.cacheArea;
<span class="j-sym">}

</span><span class="j-key">private </span><span class="j-typ">boolean </span>haveVolume;
<span class="j-key">private </span>BigDecimal cacheVolume;
<span class="j-key">public </span>BigDecimal getVolume<span class="j-sym">()
{
  </span><span class="j-key">if </span><span class="j-sym">(</span>!<span class="j-key">this</span>.haveVolume<span class="j-sym">) {
    </span><span class="j-key">this</span>.cacheVolume = getArea<span class="j-sym">()</span>.multiply<span class="j-sym">( </span>getSide<span class="j-sym">() )</span>;
    <span class="j-key">this</span>.haveVolume = <span class="j-key">true</span>;
  <span class="j-sym">}
  </span><span class="j-key">return this</span>.cacheVolume;
<span class="j-sym">}

</span><span class="j-key">public </span><span class="j-typ">void </span>reset<span class="j-sym">() 
{
  </span><span class="j-key">this</span>.haveSide = <span class="j-key">false</span>;
  <span class="j-key">this</span>.haveArea = <span class="j-key">false</span>;
  <span class="j-key">this</span>.haveVolume = <span class="j-key">false</span>;
<span class="j-sym">}</span></pre>
<p>Clearly, this is a lot more code than for the non-caching version. It is important to realize, however, that SEJ only caches intermediate cell values which are referenced more than once in the computation. All others are inlined into the single expression that references them. Cells that are not referenced at all don't appear in the computation at all, either.</p>        </div>
        <div class="footer">
<p>Copyright &copy; 2006 Peter Arrenbrecht. All rights reserved.
<br/>Last updated on 18.05.2006.</p>        </div>
    </div>
</body>
</html>