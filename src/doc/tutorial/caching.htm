<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
	<meta http-equiv="Content-Type" content="text/html; charset=iso-8859-1" />
    <title>Caching Of Values in SEJ - arrenbrecht.ch</title>
    <style type="text/css" media="screen">
        @import "../style.css";
	
    </style>
    <link rel="stylesheet" type="text/css" media="print" href="../printstyle.css" />
	<script type="text/javascript" src="../scripts.js"></script>
	
</head>
<body onload="body_loaded();">
    <div class="all">
        <div class="nav">
            <p class="nav">
<a href="http://www.arrenbrecht.ch/">arrenbrecht.ch</a> &gt;
<a href="../index.htm">SEJ</a> &gt;
<a href="index.htm">Tutorial</a> &gt;

			</p>
        </div>
        <div class="title">
            <h1>
                Caching Of Values in SEJ</h1>
        </div>
        
        
        <div class="content">
        
<p>Many computations can be sped up considerably by caching intermediate results. Here I show how to make an engine cache input values and intermediate cell values internally.</p><div class="toc">
<p id="pagetoc" hfrom="2" hto="3"><i>Table Of Contents missing - need to enable JavaScript?</i></p>
</div>

<h2>Motivation</h2>
<p>Consider the following example spreadsheet doing the computation of a square's area and a cube's volume, given the side length. The cell B1 is the sole input, B3 and B4 are outputs.</p>
<p>[xc:testdata/sej/tutorials/Caching.xls]</p>
<p>As you can see, the area is reused by the volume computation. This is, of course, a very simple example. But even here, if we were to compute millions of areas and volumes using <tt>BigDecimal</tt> and side lengths of great precision, it might already pay off to cache the intermediate value for the area.</p>
<p>Also, the value for side is used three times in all. Assuming it is expensive to obtain the side length (maybe it involves a database access), it might also pay off to cache this value. This value could of course be cached by the application itself. However, since SEJ supports automatic internal caching anyway, it also relieves you of the tedium of manually caching input values.</p>
<p>Finally, SEJ also caches output values, just in case you want to access them multiple times, without having to cache them yourself.</p>

<h5>Note</h5>
<p>Caching of input values also encourages a functional view of computations, i.e. input value accessors that have no side effects. Since you cannot know beforehand how many times a spreadsheet will access your input values, having side effects in them is very likely a bad idea.</p>

<h2>Default Is No Caching</h2>
<p>Normally, computations generated by SEJ do not cache values internally - they are essentially stateless. This ensures that they behave correctly when you call a computation multiple times while, in between, modifying the data returned by its input object. Here is an example of this:</p>
<p>[jc:sej.tutorials.Caching:---- noCache]</p>
<p>The generated computation looks essentially like this:</p>
<p>[jc:sej.tutorials.Caching:---- noCacheEngine]</p>

<h2>Turning On Caching</h2>
<p>Once a computation starts doing internal caching, that is, once it starts to have state, there must be a way for you to control that state. In particular, you have to be able to <em>reset</em> a computation when you have modified its input. Therefore, SEJ only uses internal caching if your output interface or class implements the <tt>Resettable</tt> interface:</p>
<p>[jc:sej.runtime.Resettable:---- resettable]</p>
<p>Let's do this now:</p>
<p>[jc:sej.tutorials.Caching:---- CachingOutput]</p>
<p>Compiling an engine with this output interface turns caching on. Here's what happens if we run the above example again:</p>
<p>[jc:sej.tutorials.Caching:---- cache]</p>
<p>Note how changing the input value does <b>not</b> affect the output values. This is because they are already cached from the previous access. To correct this, we have to call <tt>reset()</tt>, which SEJ implemented for us:</p>
<p>[jc:sej.tutorials.Caching:---- reset]</p>

<h5>Was it worth it?</h5>
<p>In this example, did caching pay off? We look at the simple case of just computing the area and volume once:</p>
<p>[jc:sej.tutorials.Caching:---- timed]</p>
<p>We do this for both versions and find - that caching is more than twice as fast:</p>
<p>[jc:sej.tutorials.Caching:---- timing]</p>

<h2>Caching Internals</h2>
<p>The generated caching computation looks essentially like this:</p>
<p>[jc:sej.tutorials.Caching:---- cacheEngine]</p>
<p>Clearly, this is a lot more code than for the non-caching version. It is important to realize, however, that SEJ only caches intermediate cell values which are referenced more than once in the computation. All others are inlined into the single expression that references them. Cells that are not referenced at all don't appear in the computation at all, either.</p>        </div>
        <div class="footer">
<p>Copyright &copy; 2006 Peter Arrenbrecht. All rights reserved.</p>        </div>
    </div>
</body>
</html>