
h1. Caching Of Values in AFC


Many computations can be sped up considerably by caching intermediate results. Here I show how to make an engine cache input values and intermediate cell values internally.

<%= toc 2, 3 %>


h2. Motivation

Consider the following example spreadsheet doing the computation of a square's area and a cube's volume, given the side length. The cell B1 is the sole input, B3 and B4 are outputs.

	[xc:org/formulacompiler/tutorials/Caching.xls]

As you can see, the area is reused by the volume computation. This is, of course, a very simple example. But even here, if we were to compute millions of areas and volumes using @BigDecimal@ and side lengths of great precision, it might already pay off to cache the intermediate value for the area.

Also, the value for side is used three times in all. Assuming it is expensive to obtain the side length (maybe it involves a database access), it might also pay off to cache this value. This value could of course be cached by the application itself. However, since AFC supports automatic internal caching anyway, it also relieves you of the tedium of manually caching input values.

Finally, AFC also caches output values, just in case you want to access them multiple times, without having to cache them yourself.

h5. Note

Caching of input values also encourages a functional view of computations, i.e. input value accessors that have no side effects. Since you cannot know beforehand how many times a spreadsheet will access your input values, having side effects in them is very likely a bad idea.



h2. Default Is No Caching

Normally, computations generated by AFC do not cache values internally - they are essentially stateless. This ensures that they behave correctly when you call a computation multiple times while, in between, modifying the data returned by its input object. Here is an example of this:

	[jc:org.formulacompiler.tutorials.Caching:---- noCache]

The generated computation is:

	[jc:caching/plain/org.formulacompiler.gen.$Root]



h2. Turning On Caching

Once a computation starts doing internal caching, that is, once it starts to have state, there must be a way for you to control that state. In particular, you have to be able to _reset_ a computation when you have modified its input. Therefore, AFC only uses internal caching if your output interface or class implements the @Resettable@ interface:

	[jc:org.formulacompiler.runtime.Resettable:---- resettable]

Let's do this now:

	[jc:org.formulacompiler.tutorials.Caching:---- CachingOutput]

Compiling an engine with this output interface turns caching on. Here's what happens if we run the above example again:

	[jc:org.formulacompiler.tutorials.Caching:---- cache]

Note how changing the input value does *not* affect the output values. This is because they are already cached from the previous access. To correct this, we have to call @reset()@, which AFC implemented for us:

	[jc:org.formulacompiler.tutorials.Caching:---- reset]

h5. Was it worth it?

In this example, did caching pay off? We look at the simple case of just computing the area and volume once:

	[jc:org.formulacompiler.tutorials.Caching:---- timed]

We do this for both versions and find - that caching is more than twice as fast:

	[jc:org.formulacompiler.tutorials.Caching:---- timing]



h2. Caching Internals

The generated caching computation looks like this:

	[jc:caching/caching/org.formulacompiler.gen.$Root]

Clearly, this is a lot more code than for the non-caching version. It is important to realize, however, that AFC only caches intermediate cell values which are referenced more than once in the computation. All others are inlined into the single expression that references them. Cells that are not referenced at all don't appear in the computation at all, either.
