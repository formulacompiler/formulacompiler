
h1. @LOOKUP@, @MATCH@, and @INDEX@

The @LOOKUP@ function, and its foundations @MATCH@ and @INDEX@, are likely to be heavily used in Abacus' financial applications. So they must be implemented efficiently both space- and runtime-wise. 

<%= toc %>


h2. Fixed-size Tables

Most lookup tables are going to be constant, I predict. Often they will be largish tables of data imported from official sources, like tax rates of different sorts.


h3. @MATCH@

An efficient implementation of @MATCH@ for such constant tables uses an array. The array allows for memory-efficient representation of the table data, and for time-efficient search. Consider:

	[xc:org/formulacompiler/tests/LookupTest.xls:MatchConsts]

which is implemented as:

	[jc:impl/lookup/matchconsts/org.formulacompiler.gen.$Root:---- fragment]

where @fun_MATCH_Ascending@ performs a binary search, as Excel does. If the array contains values computed at runtime as in:

	[xc:org/formulacompiler/tests/LookupTest.xls:MatchInputs]
	
we augment this to:

	[jc:impl/lookup/matchinputs/org.formulacompiler.gen.$Root:---- fragment]

I did not merge @$arr$0()@ into @$constarr$0()@ because this allows me to reuse the constant part of the array when the computation is @reset()@.

h5. Unrolling

I also considered unrolling the array and search, but for large tables this would lead to significant code bloat, which hurts memory-efficiency and JIT performance. Whereas the predefined search functions on the runtime used above can be JITted efficiently.

When most or all array values are computed, and maybe even expensive to compute, then unrolling is probably the better approach as it avoids computing cells not touched by the search. But this sounds like a highly improbable scenario, so I won't address it.

Lookups into very small tables might also perform better if unrolled. Array setup might just turn out to be too expensive for them. But, while nifty, this adds too much complexity for too little gain, I believe. And people needing the speed can rewrite their small lookups to nested @IF@s anyway.


h3. @INDEX@

For @INDEX@ I see two approaches: using arrays as above, or using a big @switch@. I did a quick check and it turns out the using @switch@ is actually more space-efficient in the .class file, as well as more memory and time-efficient. The main reason is the way constant arrays are built in Java. They are internally built as if you had assigned each element in turn. In addition to this, @switch@ also has the advantage that only the table values actually used have to be computed. So for:

	[xc:org/formulacompiler/tests/LookupTest.xls:IndexConsts]

we get:

	[jc:impl/lookup/indexconsts/org.formulacompiler.gen.$Root:---- fragment]

which extends very naturally to computed values:

	[jc:impl/lookup/indexinputs/org.formulacompiler.gen.$Root:---- fragment]


h3. @LOOKUP@ etc.

Since all the variants of @LOOKUP@ are mapped to @INDEX@ and @MATCH@, this covers the lot. There is one minor peephole optimization at work, though. Whenever there is a call to @MATCH@ directly within @INDEX@, then this gets rewritten to @MATCH_INT@ returning an integer instead of double or bigdec to avoid the unnecessary conversions from and back to integer. So:

	[xc:org/formulacompiler/tests/LookupTest.xls:LookupConsts]

is:

	[jc:impl/lookup/lookupconsts/org.formulacompiler.gen.$Root:---- fragment]

The equivalent, but explicitly written:

	[xc:org/formulacompiler/tests/LookupTest.xls:IndexMatchConsts]

is also:

	[jc:impl/lookup/indexmatchconsts/org.formulacompiler.gen.$Root:---- fragment]


h3. Multiple Lookups

What if multiple, different values are looked up? Consider:

	[xc:org/formulacompiler/tests/LookupTest.xls:MultiMatchConsts]

We clearly need to factor the common construction of the array for @D12:H12@ out of the generated code for the cells @B12@ and @B13@. To do this, we first need to recognise the commonality. This is hard to do efficiently for the computation model compiler as it has no notion of cell adjacency and, thus, no notion of contiguous arrays. So the spreadsheet compiler passes on the both the range origin and extent for instances of @ExpressionNodeForArrayReference@ it generates to help the computation model compiler recognize repeated occurrences. Resulting in the single instance @$constarr$0()@:

	[jc:impl/lookup/multimatchconsts/org.formulacompiler.gen.$Root:---- fragment]

The same goes for @INDEX@, but the common code is the generated @switch@:

	[jc:impl/lookup/multiindexconsts/org.formulacompiler.gen.$Root:---- fragment]

Putting it together, we get this for @LOOKUP@:

	[jc:impl/lookup/multilookupconsts/org.formulacompiler.gen.$Root:---- fragment]

Finally, since we pass the range origin to the compiler, the rewriter can properly identify common sub-arrays such as are generated by rewriting @H/VLOOKUP@. Consider:

	[xc:org/formulacompiler/tests/LookupTest.xls:SubArrayConsts]

Both of the lookups are rewritten to @MATCH@ and @INDEX@. The arrays referenced by all three instances of @MATCH@ are then identical, but two are generated by the expression rewriter, not the spreadsheet loader. All are identified properly:

	[jc:impl/lookup/subarrayconsts/org.formulacompiler.gen.$Root:---- fragment]

Note that only the array accessors are factored out. AFC does not do full common subexpression elimination (CSE). But if you "turn on caching":../tutorial/caching.htm and rewrite the two @HLOOKUP@s to applications of @INDEX@ and the central third @MATCH@, then you get proper reuse of the @MATCH@ value.

Passing the origin might, though, be a problem for users (still hypothetical) of the model compiler itself. What origins should they use? They might not have a cube model at all. So for the future I could say that if you set the origin, then it's used. If not, then subarrays use the array's name with a special suffix.


h3. @H/VLOOKUP@ with computed sub-array index

Above we saw @HLOOKUP@ with a constant lookup row index in action. A computed row index simply results in another @switch@ to select the appropriate sub-array. So:

	[xc:org/formulacompiler/tests/LookupTest.xls:HLookupInputs]

results in:

	[jc:impl/lookup/hlookupinputs/org.formulacompiler.gen.$Root:---- fragment]

This still leaves quite a bit to be desired, like

	* Unnecessary casts to @double@ and then back to @int@.
	* Non-factored subtraction @(int) d - 1@.

But, most importantly, this is just the code for cell @B23@. It is duplicated entirely for cell @B24@, except for the @$idx$@ methods. Eliminating this would again require full blown common subexpression elimination.


h2. Input Tables of Varying Size

What if the lookup table is a repeating section? For the moment, I will not support this. Still, here are my current ideas on it.

In the current implementation of repeating sections where every element is represented by its own sub-computation instance, I see two options:

	* Build the arrays used above from the repeating data, then proceed as before. Adds additional arrays, but also caches lookup tables. This sounds like a good choice for @MATCH@.
	* Generate code that directly works on the internal sub-instance arrays for @MATCH@ and @INDEX@. Avoids the additional arrays, but repeatedly evaluates the values touched during lookup. This sounds like a good choice for @INDEX@.

If AFC ever supports memory-efficient forward-only iteration of largish repeating sections, then this would have to change. @MATCH@ and @INDEX@ would have to sequentially scan the section until the result is found. @LOOKUP@ would have to be implemented directly as scanning twice for @MATCH@ and then @INDEX@ would be silly.

