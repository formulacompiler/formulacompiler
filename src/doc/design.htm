<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
	<meta http-equiv="Content-Type" content="text/html; charset=iso-8859-1" />
    <title>SEJ Design Document - arrenbrecht.ch</title>
    <style type="text/css" media="screen">
        @import "../style.css";
	
    </style>
    <link rel="stylesheet" type="text/css" media="print" href="../printstyle.css" />
	
	<link rel="shortcut icon" href="../favicon.ico" />
	<link rel="alternate" type="application/rss+xml" title="RSS" href="http://www.arrenbrecht.ch/sej/rss.xml" />
</head>
<body>
    <div class="all">
        <div class="nav">
            <p class="nav">
<a href="../index.htm">arrenbrecht.ch</a> &gt;
<a href="index.htm">SEJ</a> &gt;


			</p>
        </div>
        <div class="title">
            <p class="nofirefox">
                This site displays best on <a href="http://www.mozilla.com/">Firefox</a>.</p>
            <h1>
                SEJ Design Document</h1>
        </div>
        
        <div class="news">
        
        

<h2>News</h2>
<p>More and better diagrams!
<br/><span class="when">May 17, 2006</span></p>        </div>
        <div class="content">
			<p class="startofcontent"/>

<h2>Introduction</h2>
<p>The Spreadsheet Engine for Java (SEJ, for short) makes it possible to use computations defined in spreadsheet files within normal Java applications. The original spreadsheet files can be created, for example, in <a href="http://office.microsoft.com/">Microsoft Excel</a> or <a href="http://www.openoffice.org/">OpenOffice Calc</a>. SEJ reads the spreadsheet files and builds corresponding Java-based formula evaluation engines. Such an engine computes output values given a set of input values. For example, compute the value of the cell <em>B3</em> given the values of the cells <em>B1</em> and <em>B2</em> as inputs.</p>
<p>The following code example should help clarify this process:</p>
<pre class="java"><span class="j-cmt">// Load and parse the spreadsheet file into memory.
</span>Spreadsheet model = SpreadsheetLoader.loadFromFile<span class="j-sym">( </span><span class="j-str">&#34;examples/testdata/sej/Test.xls&#34; </span><span class="j-sym">)</span>;

<span class="j-cmt">// Create an engine builder for the loaded spreadsheet file.
// Pass to it the input and output types.
</span>Compiler compiler = CompilerFactory.newDefaultCompiler<span class="j-sym">( </span>model, Inputs.class, Outputs.<span class="j-key">class </span><span class="j-sym">)</span>;

<span class="j-cmt">// Define which of the cells will be variable inputs to the engine.
// All inputs are bound to a method that will be called to obtain their value.
</span>Compiler.Section root = compiler.getRoot<span class="j-sym">()</span>;
root.defineInputCell<span class="j-sym">( </span>model.getCell<span class="j-sym">( </span><span class="j-num">0</span>, <span class="j-num">1</span>, <span class="j-num">0 </span><span class="j-sym">)</span>, <span class="j-key">new </span>CallFrame<span class="j-sym">( </span>Inputs.<span class="j-key">class</span>.getMethod<span class="j-sym">( </span><span class="j-str">&#34;getA&#34; </span><span class="j-sym">) ) )</span>;
root.defineInputCell<span class="j-sym">( </span>model.getCell<span class="j-sym">( </span><span class="j-num">0</span>, <span class="j-num">1</span>, <span class="j-num">1 </span><span class="j-sym">)</span>, <span class="j-key">new </span>CallFrame<span class="j-sym">( </span>Inputs.<span class="j-key">class</span>.getMethod<span class="j-sym">( </span><span class="j-str">&#34;getB&#34; </span><span class="j-sym">) ) )</span>;

<span class="j-cmt">// Define which of the cells will be computable outputs of the engine.
// Outputs are bound to prototype methods that are implemented by the engine.
</span>root.defineOutputCell<span class="j-sym">( </span>model.getCell<span class="j-sym">( </span><span class="j-num">0</span>, <span class="j-num">1</span>, <span class="j-num">2 </span><span class="j-sym">)</span>, <span class="j-key">new </span>CallFrame<span class="j-sym">( </span>Outputs.<span class="j-key">class</span>.getMethod<span class="j-sym">( </span><span class="j-str">&#34;getResult&#34; </span><span class="j-sym">) ) )</span>;

<span class="j-cmt">// Build an engine for the given spreadsheet, inputs, and outputs.
</span>Engine engine = compiler.compileNewEngine<span class="j-sym">()</span>;

<span class="j-cmt">// Compute an actual output value for a given set of actual input values.
</span>Inputs inputs = <span class="j-key">new </span>Inputs<span class="j-sym">( </span><span class="j-num">4</span>, <span class="j-num">40 </span><span class="j-sym">)</span>;
Outputs outputs = <span class="j-sym">(</span>Outputs<span class="j-sym">) </span>engine.newComputation<span class="j-sym">( </span>inputs <span class="j-sym">)</span>;
<span class="j-typ">double </span>result = outputs.getResult<span class="j-sym">()</span>;

System.out.printf<span class="j-sym">( </span><span class="j-str">&#34;Result is: %f&#34;</span>, result <span class="j-sym">)</span>;</pre>

<p>Or, graphically, where blue is your code, red is SEJ's, green are external dependencies, and yellow are generated things:</p>
<p><img src="embedded.png" alt="Overview" /></p>

<h2>Design Goals</h2>

<h3>Multiple Data Formats</h3>
<p>SEJ should be usable with at least Microsoft Excel XLS and XML files, and OpenOffice Calc files.</p>

<h3>High Performance Computation</h3>
<p>The generated engines should be suitable for use on application servers:</p>
<ul compact class="compact">
<li>Low memory consumption</li>
<li>High performance</li>
<li>Thread safe</li>
</ul>

<h3>High Performance Engine Construction</h3>
<p>The generation of an engine from a spreadsheet file, however, is considered a rarer task. So, while the above goals are still desirable for it, the focus is clearly on making the engines perform exceptionally well, not engine generation. Nevertheless, engine generation must be suitable for being performed occasionally by an application server.</p>

<h3>Cheap Instantiation</h3>
<p>Because generation of an engine may be an expensive task, it must be possible to store generated engines and then later efficiently instantiate them from the storage. The original spreadsheet file should not be required for this instantiation.</p>

<h3>Usability</h3>
<p>Errors in the spreadsheet file or errors during engine generation due to limitations of SEJ must be pinpointed and described in a way that allows typical spreadsheet users to correct or work around the problem.</p>

<h3>Documentation</h3>
<p>The range of supported formula elements must be clearly documented using automated tests.</p>

<h3>Trustworthiness</h3>
<p>SEJ in its standard operation generates byte code for the Java VM. This is not something most programmers read and understand with ease. SEJ must therefore also be able to generate Java source code. All automated tests should run both with bytecode and with sourcecode generation, and the tests should ascertain that the bytecode compiled from the source by the Java compiler is the same as the one compiled by directly by SEJ. This way, users who mistrust bytecode generation, or who need to see what an engine generated by SEJ does internally, can rely on the generated source code.</p>

<h2>Requirements</h2>

<h3>Version 1</h3>
<ol>
<li>Be able to handle Microsoft Excel XLS and XML files.</li>
<li>Handle formulas involving only numeric values which fit into the Java Double type.</li>
<li>Support all standard arithmetic operators, such as +, -, *, /, and parentheses.</li>
<li>Support SUM() over arbitrary ranges and collections of cells.</li>
<li>Support named cell references in formulas.</li>
<li>Handle any number of single cell inputs and outputs.</li>
</ol>

<h3>Version 2</h3>
<ol>
<li>Handle input ranges of varying dimensions. In particular, handle the case where an array of data must be pasted into a cell range in the spreadsheet, possibly requiring the cell range to grow or shrink.</li>
<li>Support computing values using BigDecimal instead of Double.</li>
<li>Support String-valued computations.</li>
</ol>

<h2>Design</h2>
<p>Derived from the design goals above is a clear separation of phases and concerns into individual components:</p>
<p><img src="compiler.png" alt="Compiler Overview" /></p><dt>API Facade</dt><dd>(Not shown in diagram.) Defines the public API to all of SEJ. For example, the interfaces <tt>Engine</tt> and <tt>Computation</tt>.</dd><dt>Spreadsheet Model</dt><dd>An in-memory representation of a spreadsheet which is constructed by loaders and consumed by engine builders. It thus decouples the engine compilers from the various spreadsheet formats supported by SEJ. Cell formulas are represented by expression trees with special nodes denoting cell references. Parsing of cell formulas into expression trees can be done lazily so that only the formulas actually used by an engine builder are parsed.</dd><dt>Computation Model</dt><dd>An in-memory representation of the relevant computation extracted from a spreadsheet model. This model is hierarchical to represent dynamic sections and has no longer any notion of rows and columns, only of expressions referencing inputs or other expressions.</dd><dt>Expression Trees</dt><dd>A syntax tree representation of the formulas found in a spreadsheet or an internal computation model.</dd><dt>Spreadsheet Compiler</dt><dd>Compiles a spreadsheet model into an internal computation model. Uses the engine definition (inputs and outputs) to extract only the relevant parts.</dd><dt>Optimizer</dt><dd>Performs constant folding and expression inlining on the internal computation model.</dd><dt>Abstract Excel Loader</dt><dd>Common base for the different Microsoft Excel spreadsheet file loaders (.xls and .xml). Implements lazy parsing of Excel formulas into SEJ's expression trees. The expression parser is generated using the open-source JFlex and CUP components.</dd><dt>Excel .xls Loader</dt><dd>Loads spreadsheet files in Microsoft Excel's native .xls format into an SEJ spreadsheet model. Uses the open-source JExcelAPI library to parse the .xls format.</dd><dt>Excel .xml Loader</dt><dd>Loads spreadsheet files in Microsoft Excel's .xml format into an SEJ spreadsheet model. Uses the open-source JDOM library to parse the XML file into a DOM.</dd><dt>OpenOffice .ods Loader</dt><dd>Envisioned loader(s) for the OpenOffice spreadsheet file format(s).</dd><dt>SEJ Bytecode Compiler</dt><dd>Builds an SEJ engine given an internal computation model. Uses the open-source ASM library to generate the new engine class and the methods which compute the spreadsheet formulas. The generated class can be used directly to instantiate an engine, or else stored somewhere for later instantiation. It is thus possible to build the engine in a separate configuration program and then install only the generated class file with its minimal dependencies in a server application.</dd><dt>Engine Instance</dt><dd>Expression evaluation engine that computes formulas using native Java byte code methods. Some computations of core spreadsheet functions are delegated to a SEJ runtime library (not shown). This implementation of an engine is very fast and space efficient. It also has no other dependencies on external components. It is, therefore, an ideal choice for heavily used server-side computations.</dd>

<h2>Realization of Design Goals</h2>
<p>How are the design goals addressed by this design?</p>

<h3>Multiple Data Formats</h3>
<p>The design decouples the engines and engine builders completely from the physical representation of spreadsheets in files. This makes it fairly straightforward and inexpensive to add new formats. Use of JFlex/CUP to generate the formula expression parsers makes supporting new expression syntaxes fairly easy.</p>
<p>SEJ has a simple workbook loader registry. Once appropriate loaders are registered, a spreadsheet file can be opened with a generic call. The loaders look at the file's extension to determine the appropriate one to use.</p>
<pre class="java"><span class="j-cmt">// Register the Microsoft Excel loaders.
</span>ExcelXLSLoader.register<span class="j-sym">()</span>;
ExcelXMLLoader.register<span class="j-sym">()</span>;

<span class="j-cmt">// Load and parse the spreadsheet files into memory.
</span>Spreadsheet model1 = SpreadsheetLoader.loadFromFile<span class="j-sym">( </span><span class="j-str">&#34;Test.xls&#34; </span><span class="j-sym">)</span>;
Spreadsheet model2 = SpreadsheetLoader.loadFromFile<span class="j-sym">( </span><span class="j-str">&#34;Test.xml&#34; </span><span class="j-sym">)</span>;</pre>

<h3>High Performance Computation</h3>
<p>The separation of the Engine and Computation interfaces allows the concurrent use of an engine across multiple threads. Each thread simply creates its own computations on the central engine. Engines are thus fully thread-safe and non-blocking.</p>
<pre class="java"><span class="j-cmt">// Compute an actual output value for a given set of actual input values.
</span>Inputs inputs = <span class="j-key">new </span>Inputs<span class="j-sym">( </span><span class="j-num">4</span>, <span class="j-num">40 </span><span class="j-sym">)</span>;
Outputs outputs = <span class="j-sym">(</span>Outputs<span class="j-sym">) </span>engine.newComputation<span class="j-sym">( </span>inputs <span class="j-sym">)</span>;
<span class="j-typ">double </span>result = outputs.getResult<span class="j-sym">()</span>;</pre>
<p>The byte code engine is extremely fast as all necessary expressions from the spreadsheet model - after constant folding - have been compiled to native Java byte code. A byte code engine depends neither on the spreadsheet model nor on anything else except for SEJ's runtime classes.</p>

<h3>High Performance Engine Construction</h3>
<p>As stated above, in most scenarios performance of the construction of engines is not as critical as performance of the constructed engines themselves. Nevertheless, the design should allow for optimization of engine construction should it become necessary.</p>
<p>Engine construction can be separated into two distinct steps:</p>
<ol>
<li>Parse the spreadsheet file into an SEJ spreadsheet model.</li>
<li>Construct an engine (or multiple different engines) from the model for a given set of inputs from which the engine is to be able to compute a given set of outputs.</li>
</ol>
<pre class="java"><span class="j-cmt">// Load and parse the spreadsheet file into memory.
</span>Spreadsheet model = SpreadsheetLoader.loadFromFile<span class="j-sym">( </span><span class="j-str">&#34;examples/testdata/sej/Test.xls&#34; </span><span class="j-sym">)</span>;

<span class="j-cmt">// Create an engine builder for the loaded spreadsheet file.
// Pass to it the input and output types.
</span>Compiler compiler = CompilerFactory.newDefaultCompiler<span class="j-sym">( </span>model, Inputs.class, Outputs.<span class="j-key">class </span><span class="j-sym">)</span>;

<span class="j-cmt">// Define which of the cells will be variable inputs to the engine.
// All inputs are bound to a method that will be called to obtain their value.
</span>Compiler.Section root = compiler.getRoot<span class="j-sym">()</span>;
root.defineInputCell<span class="j-sym">( </span>model.getCell<span class="j-sym">( </span><span class="j-num">0</span>, <span class="j-num">1</span>, <span class="j-num">0 </span><span class="j-sym">)</span>, <span class="j-key">new </span>CallFrame<span class="j-sym">( </span>Inputs.<span class="j-key">class</span>.getMethod<span class="j-sym">( </span><span class="j-str">&#34;getA&#34; </span><span class="j-sym">) ) )</span>;
root.defineInputCell<span class="j-sym">( </span>model.getCell<span class="j-sym">( </span><span class="j-num">0</span>, <span class="j-num">1</span>, <span class="j-num">1 </span><span class="j-sym">)</span>, <span class="j-key">new </span>CallFrame<span class="j-sym">( </span>Inputs.<span class="j-key">class</span>.getMethod<span class="j-sym">( </span><span class="j-str">&#34;getB&#34; </span><span class="j-sym">) ) )</span>;

<span class="j-cmt">// Define which of the cells will be computable outputs of the engine.
// Outputs are bound to prototype methods that are implemented by the engine.
</span>root.defineOutputCell<span class="j-sym">( </span>model.getCell<span class="j-sym">( </span><span class="j-num">0</span>, <span class="j-num">1</span>, <span class="j-num">2 </span><span class="j-sym">)</span>, <span class="j-key">new </span>CallFrame<span class="j-sym">( </span>Outputs.<span class="j-key">class</span>.getMethod<span class="j-sym">( </span><span class="j-str">&#34;getResult&#34; </span><span class="j-sym">) ) )</span>;

<span class="j-cmt">// Build an engine for the given spreadsheet, inputs, and outputs.
</span>Engine engine = compiler.compileNewEngine<span class="j-sym">()</span>;</pre>
<p>SEJ's spreadsheet model should be designed so as to allow loaders to instantiate parts of the model lazily. This will in principle allow engines to be constructed efficiently which access only a small part of an otherwise large spreadsheet. The true need for this is not totally clear at the moment, however, because I expect users to write dedicated spreadsheets that supply computations to business applications. Currently, lazy parsing of expressions is already implemented and thus verified. Lazy instantiation of individual sheets, rows, and cells is not yet implemented and may still require some interface changes affecting both loaders and engine builders.</p>
<p>Use of JFlex/CUP should ensure efficient expression parsers.</p>
<p>Construction of an engine from an SEJ model is fairly straightforward and thus fairly cheap.</p>

<h3>Cheap Instantiation</h3>
<p>First of all, an engine, once compiled, does not depend on the original spreadsheet file, its internal model, or the compiler used to compile the engine. It also does not have any dependencies on third party libraries. So if an engine can be serialized to persistent storage, it can be deserialized again with little cost and no external dependencies. It is therefore a possible and, indeed, recommended scenario that applications should take spreadsheet files as input during configuration and compile the necessary computation engines from them. They should then store the engines somewhere for use later on at run-time. In addition to improving the production server's memory footprint and performance, this will also minimize the security risk introduced by the access to arbitrary, user-supplied spreadsheet files. This access can be delegated to an offline configuration editor, instead of being part of the production server.</p>
<p>Here's the general outline of such an approach:</p>
<p><img src="compile_and_use.png" alt="Separate Compilation" /></p>
<p>First, the configuration, which compiles an engine and stores it somewhere (a file in this example):</p>
<pre class="java"><span class="j-cmt">// Load and parse the spreadsheet file into memory.
</span>Spreadsheet model = SpreadsheetLoader.loadFromFile<span class="j-sym">( </span><span class="j-str">&#34;examples/testdata/sej/Test.xls&#34; </span><span class="j-sym">)</span>;

<span class="j-cmt">// Create an engine builder for the loaded spreadsheet file.
// Pass to it the input and output types.
</span>Compiler compiler = CompilerFactory.newDefaultCompiler<span class="j-sym">( </span>model, Inputs.class, Outputs.<span class="j-key">class </span><span class="j-sym">)</span>;

<span class="j-cmt">// Define which of the cells will be variable inputs to the engine.
// All inputs are bound to a method that will be called to obtain their value.
</span>Compiler.Section root = compiler.getRoot<span class="j-sym">()</span>;
root.defineInputCell<span class="j-sym">( </span>model.getCell<span class="j-sym">( </span><span class="j-num">0</span>, <span class="j-num">1</span>, <span class="j-num">0 </span><span class="j-sym">)</span>, <span class="j-key">new </span>CallFrame<span class="j-sym">( </span>Inputs.<span class="j-key">class</span>.getMethod<span class="j-sym">( </span><span class="j-str">&#34;getA&#34; </span><span class="j-sym">) ) )</span>;
root.defineInputCell<span class="j-sym">( </span>model.getCell<span class="j-sym">( </span><span class="j-num">0</span>, <span class="j-num">1</span>, <span class="j-num">1 </span><span class="j-sym">)</span>, <span class="j-key">new </span>CallFrame<span class="j-sym">( </span>Inputs.<span class="j-key">class</span>.getMethod<span class="j-sym">( </span><span class="j-str">&#34;getB&#34; </span><span class="j-sym">) ) )</span>;

<span class="j-cmt">// Define which of the cells will be computable outputs of the engine.
// Outputs are bound to prototype methods that are implemented by the engine.
</span>root.defineOutputCell<span class="j-sym">( </span>model.getCell<span class="j-sym">( </span><span class="j-num">0</span>, <span class="j-num">1</span>, <span class="j-num">2 </span><span class="j-sym">)</span>, <span class="j-key">new </span>CallFrame<span class="j-sym">( </span>Outputs.<span class="j-key">class</span>.getMethod<span class="j-sym">( </span><span class="j-str">&#34;getResult&#34; </span><span class="j-sym">) ) )</span>;

<span class="j-cmt">// Write the engine out to its serialized form, then drop the reference to it.
</span>File engineSerializationFile = <span class="j-key">new </span>File<span class="j-sym">( </span><span class="j-str">&#34;/temp/Engine.ser&#34; </span><span class="j-sym">)</span>;
OutputStream outStream = <span class="j-key">new </span>FileOutputStream<span class="j-sym">( </span>engineSerializationFile <span class="j-sym">)</span>;
<span class="j-key">try </span><span class="j-sym">{
  </span>compiler.saveTo<span class="j-sym">( </span>outStream <span class="j-sym">)</span>;
<span class="j-sym">}
</span><span class="j-key">finally </span><span class="j-sym">{
  </span>outStream.close<span class="j-sym">()</span>;
<span class="j-sym">}</span></pre>
<p>Second, the code that would run in a production server:</p>
<pre class="java"><span class="j-cmt">// Instantiate an engine from the serialized form.
</span>InputStream inStream = <span class="j-key">new </span>FileInputStream<span class="j-sym">( </span>engineSerializationFile <span class="j-sym">)</span>;
Engine engine = EngineFactory.loadFrom<span class="j-sym">( </span>inStream <span class="j-sym">)</span>;

<span class="j-cmt">// Compute an actual output value for a given set of actual input values.
</span>Inputs inputs = <span class="j-key">new </span>Inputs<span class="j-sym">( </span><span class="j-num">4</span>, <span class="j-num">40 </span><span class="j-sym">)</span>;
Outputs outputs = <span class="j-sym">(</span>Outputs<span class="j-sym">) </span>engine.newComputation<span class="j-sym">( </span>inputs <span class="j-sym">)</span>;
<span class="j-typ">double </span>result = outputs.getResult<span class="j-sym">()</span>;

System.out.printf<span class="j-sym">( </span><span class="j-str">&#34;Result is: %f&#34;</span>, result <span class="j-sym">)</span>;</pre>
<p>Note that the production server must have called StandardEngine.register() somewhere so the EngineFactory knows what type of engine to instantiate.</p>
<p>The byte code engine is really a Java class generated at run-time. Its serialization is, therefore, simply the byte array that would be stored in the .class file. Note, however, that this byte array can be stored anywhere, it need not be an actual .class file somewhere on your classpath. Instantiation of a byte code engine from external storage is, therefore, exactly what a class loader does.</p>

<h3>Usability</h3>
<p>This goal has not been specifically addressed in the current design. However, the use of JFlex/CUP to generate the expression parsers should lead to fairly good error messages when unsupported or erroneous expressions are encountered.</p>

<h3>Documentation</h3>
<p>Use of JFlex/CUP to generate the expression parsers leads to a fairly readable documentation of the supported (or, at least, parsed) expression syntax.</p>
<p>Test-driven development should ensure that all supported features are clearly documented and verified by tests. The infrastructure to add tests in a consistent way is not documented yet.</p>

<h3>Trustworthiness</h3>
<p>While not implemented yet, SEJ will be able to generate Java source code as well as byte-code:</p>
<p><img src="compilesrc_and_use.png" alt="Source Compilation" /></p>        </div>
        <div class="footer">
<p>Copyright &copy; 2006 Peter Arrenbrecht. All rights reserved.
<br/>Last updated on 18.05.2006.</p>        </div>
    </div>
</body>
</html>