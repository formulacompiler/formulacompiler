<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
	<meta http-equiv="Content-Type" content="text/html; charset=iso-8859-1" />
    <title>SEJ Developer's Journal - arrenbrecht.ch</title>
    <style type="text/css" media="screen">
        @import "style.css";
	
    </style>
    <link rel="stylesheet" type="text/css" media="print" href="printstyle.css" />
</head>
<body>
    <div class="all">
        <div class="nav">
            <p class="nav">
<a href="http://www.arrenbrecht.ch/">arrenbrecht.ch</a> &gt;
<a href="index.htm">SEJ</a> &gt;


			</p>
        </div>
        <div class="title">
            <h1>
                SEJ Developer's Journal</h1>
        </div>
        
        
        <div class="content">
        
<p>This is an unstructured journal regarding the development of SEJ. I use it to keep track of ideas, goals and discussion notes.</p>
<p>Check the <a href="roadmap.htm">roadmap</a> for the current priorities, and the <a href="releasenotes.htm">release notes</a> for what's already been done.</p>

<h2>July 11, 2006</h2>
<p>Picking up on the ideas from June 30, I added support for citing Excel spreadsheets to <a href="http://arrenbrecht.ch/jcite/">JCite</a>. Now the SEJ documentation has <a href="tutorial/repeatingsections.htm">example spreadsheets</a> in it that are automatically tested and nicely formatted with every release. Cool.</p>

<h2>July 6, 2006</h2>
<p>Been busy implementing repeating sections. Read-only version is nearly finished. Just realized that engines with repeating sections will need to be resettable because the section collections are always cached.</p>

<h2>June 30, 2006</h2>

<h3>Authoring Sheets</h3>
<p>I have been thinking some more about the people who will have to author custom computations as spreadsheets. While SEJ must be able to work with almost any sheet, we should still strive to provide a more pleasurable experience to sheet authors than just basic Excel. Here are my current ideas:</p>
<ul class="spaced">
<li>Write an Excel add-in that makes managing names easier. Might be a task-pane that lists all names and translates mangled parametrized calls to proper syntax. (For example: <tt>valueFor.1994</tt> becomes <tt>valueFor( 1994 )</tt>.)</li>
<li>Write an Excel add-in that reads an i/o definition generated from the respective Java interfaces for the sheet. Then allow the user to paste the proper names onto cells. Could also support validation of existing names (much like the binder later does, too).</li>
<li>Use color to distinguish input and output cells in the automatic, reflective binder.</li>
<li>Write a tool that generates end-user documentation for the defined i/o names given the respective Java interfaces.</li>
<li>Write a tool that can embed sample Excel sheets in HTML documentation (and maybe FO), complete with name annotations and formula display. This would also come in handy in the documentation of SEJ itself. In fact, what I need to document for my sample use-cases is exactly of the same sort as what applications will have to document for the specific computations they make customizable.</li>
</ul>
<p><a href="mailto:peo@arrenbrecht.ch">Feedback welcome!</a></p>

<h3><a name="DynamicParams">Dynamic Parameters</a></h3>
<p>I have started the use-case tests and tutorial on basic repeating sections. The first example is computing a customer rating given the totals of the orders for the last 3 months. With the current version of SEJ, the best we can do is something like:</p>
<pre>public OrderData[] ordersForLastNDays( int _days );</pre>

<p>However, it would be more natural to have something like:</p>
<pre>public OrderData[] ordersByDate( Date _from, Date _to );</pre>

<p>This is not something we can bind to with SEJ today. And even if we could, we would have to bind the date arguments <em>statically</em>. But they need to be dynamic, computed relative to the current date. This could be done in Excel. So we would need a way to bind an input call so that its parameters are bound to other cells. For example:</p>
<pre>   A               B
1  Today           =Date()
2  StartDate       =... (formula that computes the start of the 3 month period)
3  EndDate         =... (formula that computes the end of the 3 month period)
4
5  Order Date      Order Total
6  1.1.2000        1000.00
7  1.2.2000        1300.00</pre>

<p>We would want to bind the range <tt>A6:B7</tt> as a repeating section to <tt>ordersByDate( StartDate, EndDate )</tt>. For example, by naming it, in Excel, <tt>ordersByDate.__StartDate.__EndDate</tt>.</p>
<p>This is quite feasible. But something for a future version of SEJ. And I am not sure your typical Excel user could handle the complexity.</p>

<h2>June 28, 2006</h2>
<p>I am currently focusing on things needed by the two first Abacus projects that will use SEJ. It's great to finally have real projects use SEJ. Generates lots of feedback regarding usability of the API and functionality.</p>

<h3>Estimates</h3>
<p>I was a bit disappointed that my initial estimate of the project was so hopelessly wrong - thank God Claudio had a much better idea of how long it would take. On closer inspection, though, I believe I can somewhat defend my initial guess. I did, after all, change requirements for the project in mid-flight more than once, and quite fundamentally (think byte-code, think sections). Given that I am practically the only one on the change board right now, such things happen a little informally and, thus, are sometimes hard to discern for what they are. Nevertheless, the laurels for the most realistic estimate for the big picture of the project go to Claudio. Thanks, man!</p>

<h3>API Redesign</h3>
<p>As I said, I much redesigned the API for <a href="releasenotes.htm#0.5.0">release 0.5.0</a>. Why was that? It really was a culmination of various separate nagging doubts and ideas that I'd been harboring for a while (and which Igor reinforced):</p>
<p>Standardization</p>
<ul class="spaced">
<li>Establish and document a set of best practices on how to use SEJ. This includes using cell and range names, reflection for binding cells to methods, and warning users when something looks fishy (like unbound named cells).</li>
<li>Encourage people to follow to the best practices established by said use-case by way of making it the simplest to do. This might help to attain a certain unformity of uses of SEJ, which, in turn, will make it easier to change particulars of the lower-level API in the future.</li>
</ul>
<p>API Improvements</p>
<ul class="spaced">
<li>Introduce a straightforward API for the standard use-case, following said best practices. People don't want to see complexity when they don't need it.</li>
<li>Add support for application-defined computation factories to reduce the application's dependence on SEJ.</li>
<li>Offer the lower-level, more complex API to people needing the added control and power.</li>
<li>Make the lower-level API more flexible by separating phases (load sheet, bind cells, compile to internal model, compile to engine).</li>
<li>Expose the internal computation model as a separate way of specifying an engine. I have not done this yet, but prepared the API so that it would be easy to do so.</li>
</ul>
<p>Defensible API</p>
<ul class="spaced">
<li>Enforce a strict separation between internal and public parts. Given Java's insufficient visiblity control (no <em>friends</em>), I copied the approach taken by Sun and Eclipse by moving all internals into the <tt>sej.internal</tt> package.</li>
<li>Expose only interfaces to strictly control what features users can see.</li>
</ul>
<p>What finally prompted me to do this redesign was when, in order to implement <a href="tutorial/type_conversion.htm">automatic type conversions</a>, I needed the <a href="tutorial/basics.htm">introductory example</a> to SEJ. This example, of course, would have to be the standard use-case for SEJ, showcasing the best practices!</p>

<h2>June 20, 2006</h2>
<p><a href="releasenotes.htm">Release 0.5.0</a> is out the door. This has been a <b>major</b> API redesign, caused by the need for a simplified initial user experience with SEJ. The standard use-case is now just a few lines.</p>
<p>I shall have to take some time to write down all the thoughts that led to this redesign.</p>

<h2>May 26, 2006</h2>
<p>I am working on an introductory example for SEJ for the tutorial (because I need this to streamline the docs and tests for binding and support for multiple data types in the interface). This prompted me to resume work on the simple cell binder. What this thing really needs to do is the following:</p>
<ul class="spaced">
<li>Scan the output interface. For every method returning a type SEJ can handle, try to find a correspondingly named cell (<em>GetXY</em> or just <em>XY</em>). If found, bind it. If not, check if the method is abstract. If so, raise an error.</li>
<li>Scan the remaining unbound cell names. For every name, check the input interface for a corresponding method. If found, bind the cell to it. If not, raise an error. This can be restricted to scan only a subset of names following a given name pattern, for example, all starting with <em>I_</em>.</li>
</ul>
<p>For both inputs and outputs, I could extend this so parametrized methods can be bound. For example: <em>I_TURNOVER_2</em> would be bound to <tt>getTurnover( int yearsBack )</tt>.</p>

<h2>May 24, 2006</h2>

<h3>Automatic Conversion of Numeric Types</h3>
<p>I discussed with Marcel and Igor that SEJ should allow different numeric input and output types and automatically convert them to the internal numeric type used in computations. This would make input and output interfaces reusable for computations with different internal numeric types, as well as being more convenient. For example:</p>
<pre>public interface Input {
  double getRate();
  int getNumberOfItems();
  long getPrice();
}</pre>

<p>should be usable with both <tt>double</tt>, <tt>BigDecimal</tt> and scaled <tt>long</tt> engines. This is not so easy:</p>
<ul class="spaced">
<li>You must be aware that for scaled <tt>long</tt> and <tt>BigDecimal</tt>, the <tt>double</tt> returned by <tt>getRate()</tt> might be truncated.</li>
<li>The <tt>long</tt> returned by <tt>getPrice()</tt> is hard to interpret. In a scaled <tt>long</tt> engine, it should be treated as an <em>already scaled</em> long. Otherwise, there is no way an application can pass properly scaled longs into such an engine. For other engines, however, the <tt>long</tt> would more naturally be interpreted as a true integer type, especially since there is currently no way to tell them the implicit scaling to assume.</li>
</ul>
<p>With Java 5, we might try to circumvent the latter problem using annotations. But a goal of SEJ is JRE 1.4 compatibility. With annotations, we might have something like:</p>
<pre>public interface Input {
  double getRate();
  int getNumberOfItems();
  @ScaledLong(4) long getPrice();
}</pre>

<p>For the moment, I shall therefore support only the following automatic input conversions:</p>
<ul compact class="compact">
<li><tt>byte</tt>, treated as a true integer value</li>
<li><tt>int</tt>, treated as a true integer value</li>
<li><tt>double</tt>, truncated to fit the internal type</li>
<li><tt>BigDecimal</tt>, truncated to fit the internal type</li>
</ul>
<p>Overflows are raised as errors.</p>
<p>On the output side, I shall support:</p>
<ul compact class="compact">
<li><tt>byte</tt>, truncates the internal value</li>
<li><tt>int</tt>, truncates the internal value</li>
<li><tt>double</tt>, possibly loses precision vis-a-vis the internal value</li>
<li><tt>BigDecimal</tt>, always exact</li>
</ul>
<p>Again, overflows are raised as errors.</p>

<h2>May 23, 2006</h2>
<p>Had a meeting with Marcel, Igor, Markus and Dani of Abacus today. Lots of new todos. Nevertheless, SEJ is now ready for integration into Abacus Lohn. A conversation with Markus revealed that the currently supported range of Excel functionality will go a very long way.</p>
<p>The .ser file format should really be a .jar. Add an option for whether you want it compressed or not. It contains the generated .class files, and a .xml file representing the internal format of SEJ engines. This makes analyzing .ser files possible using standard tools.</p>
<p>Checked out goal seeking in Excel (as prompted to by Markus). This is purely a menu option, so adding this to SEJ is not really realistic. Maybe as a layer around SEJ. But then, applications can currently do that themselves.</p>

<h2>May 18, 2006</h2>

<h3>Test First</h3>
<p>I have implemented <a href="tutorial/caching.htm">caching of values</a>. This has been an elevating experience of test-first and documentation-first development.</p>
<ul class="spaced">
<li>I first wrote some notes here in the developer's journal.</li>
<li>Then I started the new topic in the tutorial and began documenting the feature, drawing on the notes I had first developed here.</li>
<li>Interleaved with the documentation I also wrote the new test cases which I immediately cited again into the documentation.</li>
</ul>
<p>This took about 3 hours. In the end, I had finished documentation and use-case tests before having written a single line of production code.</p>
<ul class="spaced">
<li>I then implemented the feature in about 1:45 h. When the use-case tests ran green, I extended my large spreadsheet-driven test suite to test both caching and non-caching versions. It ran green immediately.</li>
</ul>
<p>So cool!</p>

<h3>Constant Sharing</h3>
<p>I started looking at sharing of constant values for expensive types (<tt>BigDecimal</tt>, for instance). First, I checked that ASM properly combines equal values in the constant pool - it does.</p>
<p>Then I checked the speed of <tt>BigDecimal</tt> construction using three different approaches:</p>
<ul compact class="compact">
<li><tt>new BigDecimal( String )</tt></li>
<li><tt>BigDecimal.valueOf( long, scale )</tt></li>
<li>preconstructed in a <tt>private static final BigDecimal</tt></li>
</ul>
<p>The preconstructed case was, of course, fastest. The interesting part is that - for constants whose digits fit into a <tt>long</tt>, which should be most of them - the difference to <tt>BigDecimal.valueOf</tt> is not that big. For smaller test runs, it amounts to about 16%. For larger runs it gets closer to 30%. Construction using strings (which SEJ usess right now) is by far the slowest, being about 4 times slower than <tt>valueOf( long )</tt>.</p>
<p><em>Aside:</em> Java 6 is already measurably faster than Java 5 on this test.</p>
<p>I have thus changed SEJ so it generates preallocated <tt>BigDecimal</tt> constants using <tt>valueOf( long )</tt> wherever possible. On the JRE 1.4 I had, unfortunately, had to resort to <tt>new BigDecimal( String )</tt> for values that already were bigdecimals, because the JRE 1.4 does not support <tt>BigDecimal.precision()</tt>.</p>

<h2>May 17, 2006</h2>
<p><em>Correction:</em> <tt>BigDecimal</tt> was ok in 0.4.0, after all. The compiler inserted the rescaling directly into the code instead of handing it off to the runtime.</p>
<p>Scaled long is up and running now, passing all tests. Instead of making the runtime an instance, I had to add support for adding a last argument with runtime context information to the static runtime methods. This is because otherwise I would have had to know that I would need the runtime instance later on <b>before</b> compiling an expression's arguments (because the JVM expects the instance for a virtual call on the stack first, not last). That would have greatly complicated the compiler's design. The context argument I can conveniently push last, where required.</p>
<p>Release 0.4.1 is out.</p>

<h2>May 16, 2006</h2>
<p>Scaled <tt>long</tt> support is coming along nicely now. The one big change that's still missing is to provide the engines with an <em>instance</em> of the runtime. Before, it was sufficient to give them static access. The reason is the runtime must know about things like the scale and rounding mode and it is far simpler to embed this in the runtime once and for all instead of passing it around all the time.</p>
<p>This made me realize that the current <tt>BigDecimal</tt> operations defined in the runtime do not enforce the fixed scale. I shall fix this for 0.4.1.</p>

<h2>May 11, 2006</h2>
<p>Since I continually broke the runtime jar, I have now included dedicated runtime tests in the automated build. This also tests engine serialization and deserialization. Yes!</p>

<h2>May 9, 2006</h2>
<p>Scaled <tt>BigDecimal</tt> support is finally up and running with all tests green, both on JRE 1.4 and 1.5. Quite a refactoring session that was. I shall soon release it as version 0.4.0.</p>
<p>I had to extend Retrotranslator slightly to support some JRE 1.5 additions to <tt>BigDecimal</tt>. Retrotranslator's great design made this very simple.</p>

<h2>April 29, 2006</h2>
<p>I am working on the BigDecimal constant folder now. It irks me that I have to duplicate a lot of code in the interpreter and the byte code compiler. So I did some tests. Up to Java 5, code such as</p>
<pre>double result = getA1() + getA2() * getA3();</pre>

<p>is more than twice as fast as</p>
<pre>double result = Runtime.opPlus( getA1(), Runtime.opTimes( getA2(), getA3() ) );</pre>

<p>Starting with the Java 6 beta, however, both perform identically. This indicates (as another test already did), that the JVM from Java 6 inlines much more aggressively.</p>
<p>This indicates that in the longer run, I can get away with a scheme where the byte code compiler uses a fairly straightforward scheme of compiling expressions to static support methods in a runtime class, which are also used by the interpreter, in an equally generic fashion. What this adds, of course, is a much increased dependency of the generated engines on the runtime class.</p>

<h2>April 13, 2006</h2>
<p>Just realized that if alternative numeric types are to be supported properly, all the constant folding performed by SEJ will have to be carried out using the alternative types, too. So, for the moment, I shall simply disable constant folding for <tt>BigDecimal</tt>.</p>

<h2>April 12, 2006</h2>

<h3>Type Inference</h3>
<p>I've started working on the type annotation algorithm. A key problem seems to be when there is a difference between the <em>expected type</em> (what the outside computation wants) and the <em>inner type</em> (what the value is). Consider, for instance:</p>
<pre>BigDecimal getResult1() { return getA().multiply( BigDecimal.TEN ); }
int getResult2() { return getA() + 4; }</pre>

<p>What should <tt>getA()</tt> return? The obvious answer is, of course, the most precise of all the expected types. So it's <tt>BigDecimal</tt> here.</p>

<h5>Speed Test</h5>
<p>Consider, however, the following timings for the repeated execution of the formula <tt>x = p + p * f</tt> where <tt>p = 123.45</tt> and <tt>f = 0.076</tt> (yes, I know this can be made more efficient). I coded this formula using <tt>double</tt>, <tt>BigDecimal</tt> and both an <tt>int</tt> and a <tt>long</tt> scaled by 10'000 (the latter is thus equivalent to the <tt>Currency</tt> type found in COM and Delphi).</p>
<ul compact class="compact">
<li><tt>double</tt>: 150 ms</li>
<li><tt>int</tt>: 200 ms</li>
<li><tt>long</tt>: 550 ms</li>
<li><tt>BigDecimal</tt>: 5500 ms</li>
</ul>
<p>Times vary, but the relations are fairly stable. So <tt>double</tt> is the fastest on my machine (Intel Centrino Core Duo), closely followed by the scaled <tt>int</tt>. Both are probably not suitable for financial computations, however. Of the remaining two, the scaled <tt>long</tt> still beats <tt>BigDecimal</tt> by a factor of 8 to 10. And it might be enough for many financial applications. Particularly so if you can control the scaling factor.</p>
<p>So choosing a faster type can make a huge difference. Can SEJ do this?</p>

<h5>Multiple Versions</h5>
<p>If <tt>getA()</tt> is an input cell, we might simply generate <em>n</em> instances of <tt>getA()</tt>, one for each desired type, with appropriate conversions:</p>
<pre>BigDecimal getA_Big() { return BigDecimal.valueOf( this.inputs.getA() ); }
int getA_Int() { return this.inputs.getA(); }</pre>

<p>where</p>
<pre>interface Inputs {
  int getA();
}</pre>

<p>Let's now consider that <tt>getA()</tt> is not an input. It then is an intermediate result (that is, a non-input cell that is referenced by multiple other cells). Do we generate multiple instances of the subexpression, one for each desired type? This would be:</p>
<pre>BigDecimal getA_Big() { return getB()_Big.add( BigDecimal.valueOf( 20 )); }
int getA_Int() { return getB()_Int + 20; }</pre>

<p>assuming <tt>getB()</tt> is an input like <tt>getA()</tt> was above. This seems worthwile because we can now compute <tt>int getResult2()</tt> at full <tt>int</tt> speed.</p>

<h5>Caching</h5>
<p>What if, however, <tt>getA()</tt> were an expensive subexpression? Like a sum over a large dynamic section? Would it not be better to compute it once and cache the result? Like:</p>
<pre>BigDecimal computeA() { return /*compute the sum*/; }
BigDecimal getA_Big() {
  if (!isCached_A) {
    cache_A = computeA();
    isCached_A = true;
  }
  return cache_A;
}
int getA_Int() { return getA_Big().intValue(); }</pre>


<h5>Overflows</h5>
<p>What if all the summed cells where <tt>int</tt> themselves? Should we not sum them as <tt>int</tt>s then? What if the sum overflows?</p>

<h5>Decision</h5>
<p>SEJ must make decisions. The question is: Can you affect them and, if so, how?</p>
<p>In view of the overflow problem, I have decided that SEJ will not try to be clever about inferring fast types. Every simple addition of input values already forces escalation to a bigger and slower type, so without hints from outside, SEJ would have to infer slow types for nearly everything very quickly. Who could give the hints? The programmers cannot, because they do not know the computations performed by the sheet. So it would have to be the sheet designers. I cannot imagine them caring about and being able to specify overflow conditions.</p>
<p>What the programmers can tell SEJ is the general class of computation they are dealing with. So I will let them specify the type being used for all numeric computations by a particular engine. The choices will probably be:</p>
<ul compact class="compact">
<li><tt>double</tt></li>
<li><tt>long</tt>, with fixed, definable scale</li>
<li><tt>int</tt>, with fixed, definable scale</li>
<li><tt>BigDecimal</tt>, with optional minimum scale</li>
</ul>
<p>The responsibility for this choice, and for communicating its consequences to the sheet designers, thus rests fully with the programmers. But it does allow them to generate engines suited for precise financial or very fast pure integer computations.</p>

<h2>April 11, 2006</h2>
<p>Release 0.3.2 is out the door. Now I can turn to supporting <tt>BigDecimal</tt>.</p>
<p>I realized that SEJ should ensure that all abstract methods on the output type are bound when generating an engine.</p>

<h2>April 7, 2006</h2>
<p>Release 0.3.2 is nearing completion. I just got all the tests running again and can do a complete build, including a version of SEJ for Java 1.4 which also passes all tests. Yay! Here's the news:</p>
<ul compact class="compact">
<li><tt>sej-runtime.jar</tt> actually works now</li>
<li>More robust formula parsing</li>
<li>Better formula error reporting</li>
<li><tt>IF</tt> fully supported, including <tt>AND</tt> and <tt>OR</tt></li>
<li>Java 1.4 compatibility</li>
<li>Dropped <tt>Engine.Computation</tt></li>
</ul>
<p>Before I release, I shall have to test it manually again, and write a dedicated page about current limitations. Missing right now are, in particular:</p>
<ul compact class="compact">
<li><tt>NOT</tt> - this will be easy, I think: just call the inverse test compiler</li>
<li>Range intersection</li>
<li>Vectors</li>
<li>Excel XML</li>
<li>OOCalc</li>
<li>Sections</li>
</ul>
<p>By the way, the <tt>IF</tt> logic described below was not fully correct. But I was on the right track. It works like a charm now.</p>

<h2>April 6, 2006</h2>
<p>I'll have to try the following:</p>
<pre>public abstract class Output {
  public abstract Output newComputation( Input input );
  // ...
}</pre>

<p>and then</p>
<pre>Output engine = (Output) compiler.compileNewEngine();
Output output = engine.newComputation( input );</pre>

<p>But it is hacky! I should introduce a factory object here. Making this factory customizable would allow users to write APIs that completely decouple them from SEJ's internals, once they get an instantiated engine.</p>
<p>On the topic of Excel formula parsing, I have now gotten the grammar right, I think. I split the lexer into two versions, one for A1-style cell references (for Excel's .xls format as returned by JExcelAPI), and another for R1C1-style references (for Excel's .xml format). This allows me to much better recognize cell references versus names. And it cleared up the parsing code quite a bit.</p>
<p>Robert told me in more detail about his problems with SEJ. I have written a very long reply, which I will use as the basis for a better exposition of SEJ's design decisions. In summary, I believe he is right that I should not have dived headlong into Java 5 for not very strong reasons. Apart from that, though, I still believe SEJ's design to be very sound.</p>

<h2>April 4, 2006</h2>
<p>Got feedback from Robert Zachajewicz of <a href="http://www.together.at/">together.at</a> on SEJ yesterday. He said that for his needs, SEJ was too strongly tied to particular Java versions and could not be isolated enough from the rest of his application for his liking. I have asked him to elaborate, since I do not yet see the full merit of his point.</p>
<p>Nevertheless, it got me thinking about this myself (it's always good to get criticism you can take constructively). I realized I can drop the requirement that the ouptut type be a descendant class of <tt>Engine.Computation</tt>, and, in fact, a class at all. It can be an interface too. I can then drop the <tt>Engine.Computation</tt> class entirely. This further reduces the noise introduced by SEJ into your own types.</p>
<p>One aspect where he is right is in the planned design of the system tests. The byte code produced from SEJ's generated Java source by the Java compiler is compared to the byte code SEJ produces directly (using ASM). This is, admittedly, highly version specific. It is, however, only an issue for running SEJ's own system tests, not for using it. I intend to do it do ensure that the two generators (source code and byte code) in SEJ actually produce the same output. This should raise the confidence that the source output can be used to gain insight by users of SEJ when something in a byte code computation does not seem to work.</p>
<p>While I knew I had tested SEJ against the JRE 1.4 before, I started reading about <tt>-target jsr14</tt> some more. And indeed this option is not officially supported by Sun. So I now use <a href="http://retrotranslator.sourceforge.net/">Retrotranslator</a> to generate 1.4 compatible .jars.</p>

<h2>March 30, 2006</h2>

<h3>Cells, Ranges and Names</h3>
<p>Excel ranges and names are tricky. Here are some examples:</p><dl><dt><tt>=SUM(2:5)</tt></dt><dd>sums the entire rows 2 through 5.</dd><dt><tt>=SUM(B:D)</tt></dt><dd>sums the entire columns B through D.</dd><dt><tt>=SUM(namedrange)</tt></dt><dd>sums the named range.</dd><dt><tt>=namedrange</tt></dt><dd>is an error, unless the range is unidimensional and the referencing cell is in a parallel range to the named one. However, in such a cell, <tt>=SUM(namedrange)</tt> still sums the entire range, not just the unidimensional cut through a possibly multidimensional range.</dd></dl>
<p>The last rule deserves an example:</p>
<pre>Income  Expense  Profit
  $100      $80  =Income-Expense =&gt; $180
  $200     $160  =Income-Expense =&gt; $360</pre>

<p>will work if column A is named <em>Income</em> and column B is named <em>Expense</em>. However</p>
<pre>IncomeA  IncomeB  Wrong!                  Expected
   $100     $200  =SUM(Incomes) =&gt; $600!      $300
   $120     $180  =SUM(Incomes) =&gt; $600!      $300</pre>

<p>will not work as expected if <em>Incomes</em> is defined as A2:B3. If you simply define column A2:A3 as <em>IncomeA</em> and column B2:B3 as <em>IncomeB</em> and write:</p>
<pre>IncomeA  IncomeB  Wrong!                          Expected
   $100     $200  =SUM(IncomeA;IncomeB) =&gt; $600!      $300
   $120     $180  =SUM(IncomeA;IncomeB) =&gt; $600!      $300</pre>

<p>it is still wrong. This, however, works:</p>
<pre>IncomeA  IncomeB  Correct                   Expected
   $100     $200  =IncomeA+IncomeB =&gt; $300      $300
   $120     $180  =IncomeA+IncomeB =&gt; $300      $300</pre>

<p>This can become rather pathological because the seemingly scalar functions <tt>AND</tt> and <tt>OR</tt> are actually aggregators, whereas <tt>NOT</tt> is scalar:</p>
<pre>One    Two   Surprise!                 Expected
TRUE   TRUE  =AND(One;Two) =&gt; FALSE!!  TRUE
FALSE  TRUE  =AND(One;Two) =&gt; FALSE    FALSE</pre>

<p>What's worse, there is, as far as I know, no scalar equivalent for <tt>AND</tt> and <tt>OR</tt>, as <tt>+</tt> is for <tt>SUM</tt>.</p>
<p>All this leads to some complicated rules for cell and range parsing in Excel expressions. While researching this, I came up with the following web links:</p>
<ul compact class="compact">
<li><a href="http://ewbi.blogs.com/develops/2004/12/excel_formula_p.html">A JavaScript online parser</a></li>
<li><a href="http://www.codecomments.com/archive285-2005-7-538549.html">Attempt at a BNF grammar</a></li>
<li><a href="http://www.mcs.vuw.ac.nz/~db/FishBrainWiki?Excel">Another one</a></li>
<li><a href="http://chacocanyon.com/smm/readings/referenceoperators.shtml">Overview of Excel operators</a></li>
</ul>
<p>Here's a few points worth noting:</p>
<ul class="spaced">
<li>For some other reason Excel uses a space (or multiple spaces) as the range intersection operator. While not as ambiguous as the comma, it does require some consideration.</li>
<li>Don't forget that Excel still allows functions to be preceded with an <em>@</em>.</li>
<li>Don't forget that array constants (surrounded by braces <tt>{}</tt>) can contain rows, which are delimited with semicolons <tt>;</tt>.</li>
<li>The text either side of a colon are not always cell references. Sometimes they are numbers (eg. <tt>$25:26</tt>).</li>
<li>A plus is not always a plus, sometimes it’s a unary operator, sometimes a binary operator, sometimes the significant figure in scientific notation. eg. <tt>12E+20</tt>.</li>
</ul>
<p>My current attempt at a BNF grammar looks like what follows. Note the possible ambiguity where <tt>name</tt> occurs in multiple places.</p>
<pre>expr ::=
    cell
  | expr + expr
  ...
  | SUM( ranges ).

ranges ::=
    range {"," range}.

range ::=
    name
  | coords ":" coords
  | col ":" col
  | row ":" row.

cell ::=
    name
  | coords.

coords ::=
  | col row
  | "R" {index} "C" {index}.

index ::=
    &lt;integer&gt;
  | "[" &lt;integer&gt; "]".

col ::= ident.
row ::= &lt;integer&gt;.
name ::= ident.</pre>


<h3>Compiling <tt>IF</tt></h3>
<p>It took me a while to figure out how to compile <tt>IF</tt> statements the way the Java compiler does. While I haven't gotten around to implementing it yet, I believe the trick is to have two modes for compilation. I call them <em>branch-false</em> and <em>branch-true</em>. In <em>branch-false</em>, the test branches to a supplied label if the condition is false, otherwise falls through. <em>branch-true</em> reverses this. The reversal is used when compiling <tt>OR</tt> in <em>branch-false</em> (and, conversely, <tt>AND</tt> in <em>branch-true</em>).</p>
<p><em>branch-false</em> does:</p>
<pre>void compileOr( Node a, Node b, Label branch ) {
  Label otherTest = newLabel();
  BRANCH_TRUE.compileTest( a, otherTest );
  mark( otherTest );
  compileTest( b, branch );
}
void compileAnd( Node a, Node b, Label branch ) {
  compileTest( a, branch );
  compileTest( b, branch );
}</pre>

<p><em>branch-true</em> does:</p>
<pre>void compileOr( Node a, Node b, Label branch ) {
  compileTest( a, branch );
  compileTest( b, branch );
}
void compileAnd( Node a, Node b, Label branch ) {
  Label notMet = newLabel();
  BRANCH_FALSE.compileTest( a, notMet );
  compileTest( b, branch );
  mark( notMet );
}</pre>

<p>The initial call is:</p>
<pre>void compileIf( Node test, Node iftrue, Node iffalse ) {
  Label notMet = newLabel();
  Label done = newLabel();
  BRANCH_FALSE.compileTest( test, notMet );
  compileExpr( iftrue );
  compileGoto( done );
  mark( notMet );
  compileExpr( iffalse );
  mark( done );
}</pre>


<h2>March 29, 2006</h2>
<p>When you use an input method that may throw a checked exception, you really have to declare that exception on each and every output method. This is because you cannot know all the places where the author of the spreadsheet is going to use that input. Therefore, SEJ should really check that all output methods declare the union of all the declared exceptions of all the input methods. Since this affects the API, I should implement this check early on.</p>
<p>To support internal caching of multiply referenced values, a computation should support a <tt>reset()</tt> method, which you have to call prior to reusing a computation with modified inputs.</p>
<p>To minimize the dependencies of compiled engines, I should move the <tt>saveTo()</tt> functionality from the <tt>EngineFactory</tt> to the <tt>Compiler</tt>. That way, compiled engines don't even need interface to the compiler.</p>
<p>I just manually tested release 0.3.1. Had to tweak it a bit so all of the documentation gets properly included. The runtime-only .jar also did not work at all. Shall release this in 0.3.2. Lesson learned: always install and test a release.</p>

<h3>Next Steps</h3>
<ul class="spaced">
<li>Implement full boolean expression support for <tt>IF</tt>, including <tt>AND</tt> and <tt>OR</tt>.</li>
<li>Implement support for <tt>BigDecimal</tt>. This might be possible without full type inference by simply substituting <tt>BigDecimal</tt> for <tt>double</tt> everywhere.</li>
<li>Write an outline of the type inference strategy so implications on the API can be caught.</li>
<li>Decide on how serialized engines will be stored for both maximum load performance and maximum robustness when SEJ evolves.</li>
</ul>

<h3>Suggestions</h3>
<ul class="spaced">
<li>Do a simple writer that generates an Excel worksheet based on an SEJ model. This is for applications that create the SEJ models themselves given legacy data or formulas defined in a custom UI. They can then write out a template spreadsheet for when users want to switch to spreadsheet mode.</li>
</ul>

<h2>March 21, 2006</h2>
<p>Everything is up and running again except for:</p>
<ul compact class="compact">
<li>empty cells</li>
<li>strings</li>
<li>INDEX and MATCH</li>
<li>subsections (bands)</li>
<li>binding outputs with parameters (needed for interactive demo)</li>
</ul>

<h2>March 18, 2006</h2>
<p>Just finished reading <em>Better, faster, lighter Java</em>. It made me realize I have to think a bit more about the exceptions I expose. Here are my rules:</p>
<ul class="spaced">
<li>Anything that is a violation of the API contract should not be a declared exception. This is not a situation you want to catch, it is one you want to avoid.</li>
<li>All internal exceptions should be converted to SEJ-specific exceptions (with <tt>cause</tt> set appropriately) so client code is not affected when loader, compiler, or engine implementations are swapped.</li>
<li>Separate phases. Model errors, compiler errors, and computation errors should not be mixed up.</li>
</ul>

<h5>throws</h5>
<p>I also did some experiments about what happens when input methods throw declared exceptions. It is as I suspected: the processing of <tt>throws</tt> is purely a compiler thing. The VM does not enforce adherence. So if you have an input method like this:</p>
<pre>  public String readFile( String _name ) throws IOException  ...</pre>

<p>and use it in a computation that you bind to an output method like this:</p>
<pre>  public abstract String getData();</pre>

<p>the output method generated by SEJ will be able to actually throw the undeclared <tt>IOException</tt>!</p>
<p>Since the list of declared thrown exceptions is available through reflection, I think SEJ should, in the future, propagate them through computations and check that bound output methods conform to them. This will be mandatory for the source generator anyway, as it needs to properly place <tt>throws</tt> clauses on the generated methods.</p>

<h5>Usability</h5>
<p>I shall have to put a façade on the current compiler interface to simplify engine definition. In particular, this façade will handle section scopes and the lookup of both cell names and the methods on the supplied input/output types.</p>
<p>I shall probably also add convenience classes that fully automate engine definition through reflection and cell names in Excel.</p>

<h2>March 16, 2006</h2>
<p>It's done. I've rewritten the API and ported to old byte-code compiler over to the new design.</p>
<p>I think I shall use version numbers in the class name for the runtime support for the engine. That way, I can easily support multiple versions of stored engines. As long as the implemented interfaces on the engines don't change, that is.</p><dl><dt>Bill Venners <a href="http://www.artima.com/insidejvm/ed2/security2.html">writes</a></dt><dd><em>Although you can grant special access privileges between types belonging to the same package by giving members protected or package access, this special access is granted to members of the same package at runtime only if they were loaded by the same class loader.</em></dd></dl>
<p>This means one has to declare all interfaces to the engine (inputs and outputs) public, even though they very clearly should often be at most package visible.</p>

<h5>Typing</h5>
<p>Right now, the engine supports only <tt>double</tt>-valued computations. It already extends this to <tt>Date</tt>s by simply converting between doubles and dates in the input interface. The output interface does not handle this yet. For the near future, booleans will be handled as doubles too. Excel internally uses 0 for false, 1 for true (and, yes, you can add them).</p>
<p>Which leaves me with the need for data type analysis only for strings and integers. Strings are essential in the long run. Integers (and longs) would allow much faster pure integer computations.</p>

<h2>March 10, 2006</h2>
<p>I have decided to drop support for the interpreted engine. Still need to verify this with Claudio, though. It will make the API much simpler, in particular the provision of default implementations for output methods not bound to the sheet. And it will let me concentrate my efforts on the one implementation that will deliver the best performance anyway.</p>
<p>The reason is that the interpreted engine cannot support the construction of a computation that descends from a user-supplied base class. If this is possible, however, the specification of the output interface, including default behaviour, becomes very simple. The user simply writes a base class that SEJ should descend the generated computation from. This class can either be abstract, partially abstract, or fully implemented with default behaviour for all getters.</p>
<p>What's more, since a generated byte-code class will be very much self-contained and rely only on a few interfaces to support classes, the long-term compatibility of the generated engines will be much improved.</p>

<h2>March 8, 2006</h2>
<p>Started <a href="tutorial.htm">tutorial</a>. Realized that the old API can be replaced by the new, interface-based one (which is the more common case anyway).</p>

<h2>March 7, 2006</h2>
<p>When you have an input interface that throws an exception, Java's reflection mechanism converts that to an <tt>InvocationTargetException</tt>. In order to be able to catch this exception when accessing an output cell, however, you have to declare <tt>InvocationTargetException</tt> on the output interface. If you don't, Java will throw an <tt>UndeclaredThrowableException</tt>.</p>
<p>I have rethought the interface based API. There is an incomplete prototype in the scratchpad right now. I still need to flesh out the sample implementation both for a generic and a byte-code implementation.</p>

<h5>Labels</h5>
<p>I discovered that Excel can accept cell <em>labels</em> in formulas. This means you can actually do something like:</p>
<pre>   A       B
1  f(10)   100
2  x(20)   200
3  Result  =f(10) + x(20)</pre>

<p>Not bad, eh? I don't know, however, whether JExcelAPI handles this properly.</p>

<h2>March 1, 2006</h2>
<p>The next steps I take with SEJ should help to finalize the API. They are:</p>
<ul class="spaced">
<li>Introduce the <tt>interface</tt> based binding. Make it so that for native code compilers, this can be as efficient as possible, obviating the need for all by-name lookups. Interface-based binding should support parametrized inputs, for example YA_1000 -&gt; getYA( 1000 ). Support multiple input interfaces.</li>
<li>Introduce API for names in model so compiler definition code can react to definitions.</li>
<li>Clean up handling of bands. Rethink terminology (again).</li>
<li>Write an outline of the type inference strategy so implications on the API can be caught.</li>
<li>Write a tutorial for both by-name an by-interface binding, including bands and values provided by callbacks.</li>
<li>Decide on how serialized engines will be stored for both maximum load performance and maximum robustness when SEJ evolves.</li>
</ul>

<h4>Bands</h4>
<p>I think bands should not be automatically extended across the entire width or height of the spreadsheet. This would allow one to build spreadsheets like:</p>
<pre>  Location     In       Out
  One          SUM(In)  SUM(Out)    =B-C
               $100     $50
               $200     $80
  Another      SUM(In)  SUM(Out)    =B-C
               $100     $200</pre>

<p>One would define a top-level range A2:D5 and two sub-ranges B3:B4 and C3:C4. This means that the number of <em>Ins</em> may differ from the number of <em>Outs</em>.</p>
<p>Also, the API <tt>Compiler.defineBand()</tt> is not precise. A <em>band</em>, in its accustomed meaning in report definition tools is the template for a single instance. SEJ's API, however, wants to to pass the range encompassing <em>all</em> of the sample instances in the sheet. This is also unfortunate because it makes SEJ assume that a single instances is always just one row high or one column wide. This may not always be convenient for the user.</p>
<p>SEJ does not handle sums over nested bands properly. The user must model intermediate sums for every non-leaf band. I shall accept this as a known limitation for the moment and have <a href="doc/bands.html">documented</a> it.</p>        </div>
        <div class="footer">
<p>Copyright &copy; 2006 Peter Arrenbrecht. All rights reserved.
<br/>Last updated on 12.07.2006.</p>        </div>
    </div>
</body>
</html>