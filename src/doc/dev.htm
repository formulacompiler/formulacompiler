<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
	<meta http-equiv="Content-Type" content="text/html; charset=iso-8859-1">
    <title>SEJ Developer's Journal - arrenbrecht.ch</title>
    <style type="text/css" media="screen">
        @import "../style.css";
    </style>
    <link rel="stylesheet" type="text/css" media="print" href="../printstyle.css" />
	
</head>
<body>
    <div class="all">
        <div class="nav">
            <p class="nav">
<a href="../index.htm">arrenbrecht.ch</a> &gt;
<a href="index.htm">SEJ</a> &gt;


			</p>
        </div>
        <div class="title">
            <p class="nofirefox">
                This site displays best on <a href="http://www.mozilla.com/">Firefox</a>.</p>
            <h1>
                SEJ Developer's Journal</h1>
        </div>
        
        
        <div class="content">
        
<p>This is an unstructured journal regarding the development of SEJ. I use it to keep track of ideas, goals and discussion notes.</p>

<h2>March 21, 2006</h2>
<p>Everything is up and running again except for:</p>
<ul compact class="compact">
<li>empty cells</li>
<li>strings</li>
<li>INDEX and MATCH</li>
<li>subsections (bands)</li>
<li>binding outputs with parameters (needed for interactive demo)</li>
</ul>

<h2>March 18, 2006</h2>
<p>Just finished reading <em>Better, faster, lighter Java</em>. It made me realize I have to think a bit more about the exceptions I expose. Here are my rules:</p>
<ul class="spaced">
<li>Anything that is a violation of the API contract should not be a declared exception. This is not a situation you want to catch, it is one you want to avoid.</li>
<li>All internal exceptions should be converted to SEJ-specific exceptions (with <tt>cause</tt> set appropriately) so client code is not affected when loader, compiler, or engine implementations are swapped.</li>
<li>Separate phases. Model errors, compiler errors, and computation errors should not be mixed up.</li>
</ul>

<h5>throws</h5>
<p>I also did some experiments about what happens when input methods throw declared exceptions. It is as I suspected: the processing of <tt>throws</tt> is purely a compiler thing. The VM does not enforce adherence. So if you have an input method like this:</p>
<pre>  public String readFile( String _name ) throws IOException  ...</pre>

<p>and use it in a computation that you bind to an output method like this:</p>
<pre>  public abstract String getData();</pre>

<p>the output method generated by SEJ will be able to actually throw the undeclared <tt>IOException</tt>!</p>
<p>Since the list of declared thrown exceptions is available through reflection, I think SEJ should, in the future, propagate them through computations and check that bound output methods conform to them. This will be mandatory for the source generator anyway, as it needs to properly place <tt>throws</tt> clauses on the generated methods.</p>

<h5>Usability</h5>
<p>I shall have to put a façade on the current compiler interface to simplify engine definition. In particular, this façade will handle section scopes and the lookup of both cell names and the methods on the supplied input/output types.</p>
<p>I shall probably also add convenience classes that fully automate engine definition through reflection and cell names in Excel.</p>

<h2>March 16, 2006</h2>
<p>It's done. I've rewritten the API and ported to old byte-code compiler over to the new design.</p>
<p>I think I shall use version numbers in the class name for the runtime support for the engine. That way, I can easily support multiple versions of stored engines. As long as the implemented interfaces on the engines don't change, that is.</p><dt>Bill Venners <a href="http://www.artima.com/insidejvm/ed2/security2.html">writes</a></dt><dd><em>Although you can grant special access privileges between types belonging to the same package by giving members protected or package access, this special access is granted to members of the same package at runtime only if they were loaded by the same class loader.</em></dd>
<p>This means one has to declare all interfaces to the engine (inputs and outputs) public, even though they very clearly should often be at most package visible.</p>

<h5>Typing</h5>
<p>Right now, the engine supports only <tt>double</tt>-valued computations. It already extends this to <tt>Date</tt>s by simply converting between doubles and dates in the input interface. The output interface does not handle this yet. For the near future, booleans will be handled as doubles too. Excel internally uses 0 for false, 1 for true (and, yes, you can add them).</p>
<p>Which leaves me with the need for data type analysis only for strings and integers. Strings are essential in the long run. Integers (and longs) would allow much faster pure integer computations.</p>

<h2>March 10, 2006</h2>
<p>I have decided to drop support for the interpreted engine. Still need to verify this with Claudio, though. It will make the API much simpler, in particular the provision of default implementations for output methods not bound to the sheet. And it will let me concentrate my efforts on the one implementation that will deliver the best performance anyway.</p>
<p>The reason is that the interpreted engine cannot support the construction of a computation that descends from a user-supplied base class. If this is possible, however, the specification of the output interface, including default behaviour, becomes very simple. The user simply writes a base class that SEJ should descend the generated computation from. This class can either be abstract, partially abstract, or fully implemented with default behaviour for all getters.</p>
<p>What's more, since a generated byte-code class will be very much self-contained and rely only on a few interfaces to support classes, the long-term compatibility of the generated engines will be much improved.</p>

<h2>March 8, 2006</h2>
<p>Started <a href="tutorial.htm">tutorial</a>. Realized that the old API can be replaced by the new, interface-based one (which is the more common case anyway).</p>

<h2>March 7, 2006</h2>
<p>When you have an input interface that throws an exception, Java's reflection mechanism converts that to an <tt>InvocationTargetException</tt>. In order to be able to catch this exception when accessing an output cell, however, you have to declare <tt>InvocationTargetException</tt> on the output interface. If you don't, Java will throw an <tt>UndeclaredThrowableException</tt>.</p>
<p>I have rethought the interface based API. There is an incomplete prototype in the scratchpad right now. I still need to flesh out the sample implementation both for a generic and a byte-code implementation.</p>

<h5>Labels</h5>
<p>I discovered that Excel can accept cell <em>labels</em> in formulas. This means you can actually do something like:</p>
<pre>   A       B
1  f(10)   100
2  x(20)   200
3  Result  =f(10) + x(20)</pre>

<p>Not bad, eh? I don't know, however, whether JExcelAPI handles this properly.</p>

<h2>March 1, 2006</h2>
<p>The next steps I take with SEJ should help to finalize the API. They are:</p>
<ul class="spaced">
<li>Introduce the <tt>interface</tt> based binding. Make it so that for native code compilers, this can be as efficient as possible, obviating the need for all by-name lookups. Interface-based binding should support parametrized inputs, for example YA_1000 -&gt; getYA( 1000 ). Support multiple input interfaces.</li>
<li>Introduce API for names in model so compiler definition code can react to definitions.</li>
<li>Clean up handling of bands. Rethink terminology (again).</li>
<li>Write an outline of the type inference strategy so implications on the API can be caught.</li>
<li>Write a tutorial for both by-name an by-interface binding, including bands and values provided by callbacks.</li>
<li>Decide on how serialized engines will be stored for both maximum load performance and maximum robustness when SEJ evolves.</li>
</ul>

<h4>Bands</h4>
<p>I think bands should not be automatically extended across the entire width or height of the spreadsheet. This would allow one to build spreadsheets like:</p>
<pre>  Location     In       Out
  One          SUM(In)  SUM(Out)    =B-C
               $100     $50
               $200     $80
  Another      SUM(In)  SUM(Out)    =B-C
               $100     $200</pre>

<p>One would define a top-level range A2:D5 and two sub-ranges B3:B4 and C3:C4. This means that the number of <em>Ins</em> may differ from the number of <em>Outs</em>.</p>
<p>Also, the API <tt>Compiler.defineBand()</tt> is not precise. A <em>band</em>, in its accustomed meaning in report definition tools is the template for a single instance. SEJ's API, however, wants to to pass the range encompassing <em>all</em> of the sample instances in the sheet. This is also unfortunate because it makes SEJ assume that a single instances is always just one row high or one column wide. This may not always be convenient for the user.</p>
<p>SEJ does not handle sums over nested bands properly. The user must model intermediate sums for every non-leaf band. I shall accept this as a known limitation for the moment and have <a href="doc/bands.html">documented</a> it.</p>        </div>
        <div class="footer">
<p>Copyright &copy; 2006 Peter Arrenbrecht. All rights reserved.
<br/>Last updated on 21.03.2006.</p>        </div>
    </div>
</body>
</html>