<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
	<meta http-equiv="Content-Type" content="text/html; charset=iso-8859-1" />
    <title>SEJ Developer's Journal - arrenbrecht.ch</title>
    <style type="text/css" media="screen">
        @import "../style.css";
	
    </style>
    <link rel="stylesheet" type="text/css" media="print" href="../printstyle.css" />
	
	<link rel="shortcut icon" href="../favicon.ico" />
	<link rel="alternate" type="application/rss+xml" title="RSS" href="http://www.arrenbrecht.ch/sej/rss.xml" />
</head>
<body>
    <div class="all">
        <div class="nav">
            <p class="nav">
<a href="../index.htm">arrenbrecht.ch</a> &gt;
<a href="index.htm">SEJ</a> &gt;


			</p>
        </div>
        <div class="title">
            <p class="nofirefox">
                This site displays best on <a href="http://www.mozilla.com/">Firefox</a>.</p>
            <h1>
                SEJ Developer's Journal</h1>
        </div>
        
        
        <div class="content">
        
<p>This is an unstructured journal regarding the development of SEJ. I use it to keep track of ideas, goals and discussion notes.</p>

<h2>Next Steps</h2>
<ul class="spaced">
<li>Implement support for scaled <tt>long</tt>.</li>
<li>Implement sharing of constant values for expensive types (<tt>BigDecimal</tt>, for instance).</li>
<li>Implement internal caching of multiply referenced values.</li>
<li>Implement <tt>INDEX</tt> and <tt>MATCH</tt> again.</li>
<li>Decide on how serialized byte code engines will be stored for both maximum load performance and maximum robustness when SEJ evolves.</li>
<li>Implement Java source code generation and hybrid tests. This will naturally surface the exception and partial implementation of interfaces problem.</li>
</ul>

<h2>May 9, 2006</h2>
<p>Scaled <tt>BigDecimal</tt> support is finally up and running with all tests green, both on JRE 1.4 and 1.5. Quite a refactoring session that was. I shall soon release it as version 0.4.0.</p>
<p>I had to extend Retrotranslator slightly to support some JRE 1.5 additions to <tt>BigDecimal</tt>. Retrotranslator's great design made this very simple.</p>

<h2>April 29, 2006</h2>
<p>I am working on the BigDecimal constant folder now. It irks me that I have to duplicate a lot of code in the interpreter and the byte code compiler. So I did some tests. Up to Java 5, code such as</p>
<pre>double result = getA1() + getA2() * getA3();</pre>

<p>is more than twice as fast as</p>
<pre>double result = Runtime.opPlus( getA1(), Runtime.opTimes( getA2(), getA3() ) );</pre>

<p>Starting with the Java 6 beta, however, both perform identically. This indicates (as another test already did), that the JVM from Java 6 inlines much more aggressively.</p>
<p>This indicates that in the longer run, I can get away with a scheme where the byte code compiler uses a fairly straightforward scheme of compiling expressions to static support methods in a runtime class, which are also used by the interpreter, in an equally generic fashion. What this adds, of course, is a much increased dependency of the generated engines on the runtime class.</p>

<h2>April 13, 2006</h2>
<p>Just realized that if alternative numeric types are to be supported properly, all the constant folding performed by SEJ will have to be carried out using the alternative types, too. So, for the moment, I shall simply disable constant folding for <tt>BigDecimal</tt>.</p>

<h2>April 12, 2006</h2>

<h3>Type Inference</h3>
<p>I've started working on the type annotation algorithm. A key problem seems to be when there is a difference between the <em>expected type</em> (what the outside computation wants) and the <em>inner type</em> (what the value is). Consider, for instance:</p>
<pre>BigDecimal getResult1() { return getA().multiply( BigDecimal.TEN ); }
int getResult2() { return getA() + 4; }</pre>

<p>What should <tt>getA()</tt> return? The obvious answer is, of course, the most precise of all the expected types. So it's <tt>BigDecimal</tt> here.</p>

<h5>Speed Test</h5>
<p>Consider, however, the following timings for the repeated execution of the formula <tt>x = p + p * f</tt> where <tt>p = 123.45</tt> and <tt>f = 0.076</tt> (yes, I know this can be made more efficient). I coded this formula using <tt>double</tt>, <tt>BigDecimal</tt> and both an <tt>int</tt> and a <tt>long</tt> scaled by 10'000 (the latter is thus equivalent to the <tt>Currency</tt> type found in COM and Delphi).</p>
<ul compact class="compact">
<li><tt>double</tt>: 150 ms</li>
<li><tt>int</tt>: 200 ms</li>
<li><tt>long</tt>: 550 ms</li>
<li><tt>BigDecimal</tt>: 5500 ms</li>
</ul>
<p>Times vary, but the relations are fairly stable. So <tt>double</tt> is the fastest on my machine (Intel Centrino Core Duo), closely followed by the scaled <tt>int</tt>. Both are probably not suitable for financial computations, however. Of the remaining two, the scaled <tt>long</tt> still beats <tt>BigDecimal</tt> by a factor of 8 to 10. And it might be enough for many financial applications. Particularly so if you can control the scaling factor.</p>
<p>So choosing a faster type can make a huge difference. Can SEJ do this?</p>

<h5>Multiple Versions</h5>
<p>If <tt>getA()</tt> is an input cell, we might simply generate <em>n</em> instances of <tt>getA()</tt>, one for each desired type, with appropriate conversions:</p>
<pre>BigDecimal getA_Big() { return BigDecimal.valueOf( this.inputs.getA() ); }
int getA_Int() { return this.inputs.getA(); }</pre>

<p>where</p>
<pre>interface Inputs {
  int getA();
}</pre>

<p>Let's now consider that <tt>getA()</tt> is not an input. It then is an intermediate result (that is, a non-input cell that is referenced by multiple other cells). Do we generate multiple instances of the subexpression, one for each desired type? This would be:</p>
<pre>BigDecimal getA_Big() { return getB()_Big.add( BigDecimal.valueOf( 20 )); }
int getA_Int() { return getB()_Int + 20; }</pre>

<p>assuming <tt>getB()</tt> is an input like <tt>getA()</tt> was above. This seems worthwile because we can now compute <tt>int getResult2()</tt> at full <tt>int</tt> speed.</p>

<h5>Caching</h5>
<p>What if, however, <tt>getA()</tt> were an expensive subexpression? Like a sum over a large dynamic section? Would it not be better to compute it once and cache the result? Like:</p>
<pre>BigDecimal computeA() { return /*compute the sum*/; }
BigDecimal getA_Big() {
  if (!isCached_A) {
    cache_A = computeA();
    isCached_A = true;
  }
  return cache_A;
}
int getA_Int() { return getA_Big().intValue(); }</pre>


<h5>Overflows</h5>
<p>What if all the summed cells where <tt>int</tt> themselves? Should we not sum them as <tt>int</tt>s then? What if the sum overflows?</p>

<h5>Decision</h5>
<p>SEJ must make decisions. The question is: Can you affect them and, if so, how?</p>
<p>In view of the overflow problem, I have decided that SEJ will not try to be clever about inferring fast types. Every simple addition of input values already forces escalation to a bigger and slower type, so without hints from outside, SEJ would have to infer slow types for nearly everything very quickly. Who could give the hints? The programmers cannot, because they do not know the computations performed by the sheet. So it would have to be the sheet designers. I cannot imagine them caring about and being able to specify overflow conditions.</p>
<p>What the programmers can tell SEJ is the general class of computation they are dealing with. So I will let them specify the type being used for all numeric computations by a particular engine. The choices will probably be:</p>
<ul compact class="compact">
<li><tt>double</tt></li>
<li><tt>long</tt>, with fixed, definable scale</li>
<li><tt>int</tt>, with fixed, definable scale</li>
<li><tt>BigDecimal</tt>, with optional minimum scale</li>
</ul>
<p>The responsibility for this choice, and for communicating its consequences to the sheet designers, thus rests fully with the programmers. But it does allow them to generate engines suited for precise financial or very fast pure integer computations.</p>

<h2>April 11, 2006</h2>
<p>Release 0.3.2 is out the door. Now I can turn to supporting <tt>BigDecimal</tt>.</p>
<p>I realized that SEJ should ensure that all abstract methods on the output type are bound when generating an engine.</p>

<h2>April 7, 2006</h2>
<p>Release 0.3.2 is nearing completion. I just got all the tests running again and can do a complete build, including a version of SEJ for Java 1.4 which also passes all tests. Yay! Here's the news:</p>
<ul compact class="compact">
<li><tt>sej-runtime.jar</tt> actually works now</li>
<li>More robust formula parsing</li>
<li>Better formula error reporting</li>
<li><tt>IF</tt> fully supported, including <tt>AND</tt> and <tt>OR</tt></li>
<li>Java 1.4 compatibility</li>
<li>Dropped <tt>Engine.Computation</tt></li>
</ul>
<p>Before I release, I shall have to test it manually again, and write a dedicated page about current limitations. Missing right now are, in particular:</p>
<ul compact class="compact">
<li><tt>NOT</tt> - this will be easy, I think: just call the inverse test compiler</li>
<li>Range intersection</li>
<li>Vectors</li>
<li>Excel XML</li>
<li>OOCalc</li>
<li>Sections</li>
</ul>
<p>By the way, the <tt>IF</tt> logic described below was not fully correct. But I was on the right track. It works like a charm now.</p>

<h2>April 6, 2006</h2>
<p>I'll have to try the following:</p>
<pre>public abstract class Output {
  public abstract Output newComputation( Input input );
  // ...
}</pre>

<p>and then</p>
<pre>Output engine = (Output) compiler.compileNewEngine();
Output output = engine.newComputation( input );</pre>

<p>But it is hacky! I should introduce a factory object here. Making this factory customizable would allow users to write APIs that completely decouple them from SEJ's internals, once they get an instantiated engine.</p>
<p>On the topic of Excel formula parsing, I have now gotten the grammar right, I think. I split the lexer into two versions, one for A1-style cell references (for Excel's .xls format as returned by JExcelAPI), and another for R1C1-style references (for Excel's .xml format). This allows me to much better recognize cell references versus names. And it cleared up the parsing code quite a bit.</p>
<p>Robert told me in more detail about his problems with SEJ. I have written a very long reply, which I will use as the basis for a better exposition of SEJ's design decisions. In summary, I believe he is right that I should not have dived headlong into Java 5 for not very strong reasons. Apart from that, though, I still believe SEJ's design to be very sound.</p>

<h2>April 4, 2006</h2>
<p>Got feedback from Robert Zachajewicz of <a href="http://www.together.at/">together.at</a> on SEJ yesterday. He said that for his needs, SEJ was too strongly tied to particular Java versions and could not be isolated enough from the rest of his application for his liking. I have asked him to elaborate, since I do not yet see the full merit of his point.</p>
<p>Nevertheless, it got me thinking about this myself (it's always good to get criticism you can take constructively). I realized I can drop the requirement that the ouptut type be a descendant class of <tt>Engine.Computation</tt>, and, in fact, a class at all. It can be an interface too. I can then drop the <tt>Engine.Computation</tt> class entirely. This further reduces the noise introduced by SEJ into your own types.</p>
<p>One aspect where he is right is in the planned design of the system tests. The byte code produced from SEJ's generated Java source by the Java compiler is compared to the byte code SEJ produces directly (using ASM). This is, admittedly, highly version specific. It is, however, only an issue for running SEJ's own system tests, not for using it. I intend to do it do ensure that the two generators (source code and byte code) in SEJ actually produce the same output. This should raise the confidence that the source output can be used to gain insight by users of SEJ when something in a byte code computation does not seem to work.</p>
<p>While I knew I had tested SEJ against the JRE 1.4 before, I started reading about <tt>-target jsr14</tt> some more. And indeed this option is not officially supported by Sun. So I now use <a href="http://retrotranslator.sourceforge.net/">Retrotranslator</a> to generate 1.4 compatible .jars.</p>

<h2>March 30, 2006</h2>

<h3>Cells, Ranges and Names</h3>
<p>Excel ranges and names are tricky. Here are some examples:</p><dt><tt>=SUM(2:5)</tt></dt><dd>sums the entire rows 2 through 5.</dd><dt><tt>=SUM(B:D)</tt></dt><dd>sums the entire columns B through D.</dd><dt><tt>=SUM(namedrange)</tt></dt><dd>sums the named range.</dd><dt><tt>=namedrange</tt></dt><dd>is an error, unless the range is unidimensional and the referencing cell is in a parallel range to the named one. However, in such a cell, <tt>=SUM(namedrange)</tt> still sums the entire range, not just the unidimensional cut through a possibly multidimensional range.</dd>
<p>The last rule deserves an example:</p>
<pre>Income  Expense  Profit
  $100      $80  =Income-Expense =&gt; $180
  $200     $160  =Income-Expense =&gt; $360</pre>

<p>will work if column A is named <em>Income</em> and column B is named <em>Expense</em>. However</p>
<pre>IncomeA  IncomeB  Wrong!                  Expected
   $100     $200  =SUM(Incomes) =&gt; $600!      $300
   $120     $180  =SUM(Incomes) =&gt; $600!      $300</pre>

<p>will not work as expected if <em>Incomes</em> is defined as A2:B3. If you simply define column A2:A3 as <em>IncomeA</em> and column B2:B3 as <em>IncomeB</em> and write:</p>
<pre>IncomeA  IncomeB  Wrong!                          Expected
   $100     $200  =SUM(IncomeA;IncomeB) =&gt; $600!      $300
   $120     $180  =SUM(IncomeA;IncomeB) =&gt; $600!      $300</pre>

<p>it is still wrong. This, however, works:</p>
<pre>IncomeA  IncomeB  Correct                   Expected
   $100     $200  =IncomeA+IncomeB =&gt; $300      $300
   $120     $180  =IncomeA+IncomeB =&gt; $300      $300</pre>

<p>This can become rather pathological because the seemingly scalar functions <tt>AND</tt> and <tt>OR</tt> are actually aggregators, whereas <tt>NOT</tt> is scalar:</p>
<pre>One    Two   Surprise!                 Expected
TRUE   TRUE  =AND(One;Two) =&gt; FALSE!!  TRUE
FALSE  TRUE  =AND(One;Two) =&gt; FALSE    FALSE</pre>

<p>What's worse, there is, as far as I know, no scalar equivalent for <tt>AND</tt> and <tt>OR</tt>, as <tt>+</tt> is for <tt>SUM</tt>.</p>
<p>All this leads to some complicated rules for cell and range parsing in Excel expressions. While researching this, I came up with the following web links:</p>
<ul compact class="compact">
<li><a href="http://ewbi.blogs.com/develops/2004/12/excel_formula_p.html">A JavaScript online parser</a></li>
<li><a href="http://www.codecomments.com/archive285-2005-7-538549.html">Attempt at a BNF grammar</a></li>
<li><a href="http://www.mcs.vuw.ac.nz/~db/FishBrainWiki?Excel">Another one</a></li>
<li><a href="http://chacocanyon.com/smm/readings/referenceoperators.shtml">Overview of Excel operators</a></li>
</ul>
<p>Here's a few points worth noting:</p>
<ul class="spaced">
<li>For some other reason Excel uses a space (or multiple spaces) as the range intersection operator. While not as ambiguous as the comma, it does require some consideration.</li>
<li>Don't forget that Excel still allows functions to be preceded with an <em>@</em>.</li>
<li>Don't forget that array constants (surrounded by braces <tt>{}</tt>) can contain rows, which are delimited with semicolons <tt>;</tt>.</li>
<li>The text either side of a colon are not always cell references. Sometimes they are numbers (eg. <tt>$25:26</tt>).</li>
<li>A plus is not always a plus, sometimes it’s a unary operator, sometimes a binary operator, sometimes the significant figure in scientific notation. eg. <tt>12E+20</tt>.</li>
</ul>
<p>My current attempt at a BNF grammar looks like what follows. Note the possible ambiguity where <tt>name</tt> occurs in multiple places.</p>
<pre>expr ::=
    cell
  | expr + expr
  ...
  | SUM( ranges ).

ranges ::=
    range {"," range}.

range ::=
    name
  | coords ":" coords
  | col ":" col
  | row ":" row.

cell ::=
    name
  | coords.

coords ::=
  | col row
  | "R" {index} "C" {index}.

index ::=
    &lt;integer&gt;
  | "[" &lt;integer&gt; "]".

col ::= ident.
row ::= &lt;integer&gt;.
name ::= ident.</pre>


<h3>Compiling <tt>IF</tt></h3>
<p>It took me a while to figure out how to compile <tt>IF</tt> statements the way the Java compiler does. While I haven't gotten around to implementing it yet, I believe the trick is to have two modes for compilation. I call them <em>branch-false</em> and <em>branch-true</em>. In <em>branch-false</em>, the test branches to a supplied label if the condition is false, otherwise falls through. <em>branch-true</em> reverses this. The reversal is used when compiling <tt>OR</tt> in <em>branch-false</em> (and, conversely, <tt>AND</tt> in <em>branch-true</em>).</p>
<p><em>branch-false</em> does:</p>
<pre>void compileOr( Node a, Node b, Label branch ) {
  Label otherTest = newLabel();
  BRANCH_TRUE.compileTest( a, otherTest );
  mark( otherTest );
  compileTest( b, branch );
}
void compileAnd( Node a, Node b, Label branch ) {
  compileTest( a, branch );
  compileTest( b, branch );
}</pre>

<p><em>branch-true</em> does:</p>
<pre>void compileOr( Node a, Node b, Label branch ) {
  compileTest( a, branch );
  compileTest( b, branch );
}
void compileAnd( Node a, Node b, Label branch ) {
  Label notMet = newLabel();
  BRANCH_FALSE.compileTest( a, notMet );
  compileTest( b, branch );
  mark( notMet );
}</pre>

<p>The initial call is:</p>
<pre>void compileIf( Node test, Node iftrue, Node iffalse ) {
  Label notMet = newLabel();
  Label done = newLabel();
  BRANCH_FALSE.compileTest( test, notMet );
  compileExpr( iftrue );
  compileGoto( done );
  mark( notMet );
  compileExpr( iffalse );
  mark( done );
}</pre>


<h2>March 29, 2006</h2>
<p>When you use an input method that may throw a checked exception, you really have to declare that exception on each and every output method. This is because you cannot know all the places where the author of the spreadsheet is going to use that input. Therefore, SEJ should really check that all output methods declare the union of all the declared exceptions of all the input methods. Since this affects the API, I should implement this check early on.</p>
<p>To support internal caching of multiply referenced values, a computation should support a <tt>reset()</tt> method, which you have to call prior to reusing a computation with modified inputs.</p>
<p>To minimize the dependencies of compiled engines, I should move the <tt>saveTo()</tt> functionality from the <tt>EngineFactory</tt> to the <tt>Compiler</tt>. That way, compiled engines don't even need interface to the compiler.</p>
<p>I just manually tested release 0.3.1. Had to tweak it a bit so all of the documentation gets properly included. The runtime-only .jar also did not work at all. Shall release this in 0.3.2. Lesson learned: always install and test a release.</p>

<h3>Next Steps</h3>
<ul class="spaced">
<li>Implement full boolean expression support for <tt>IF</tt>, including <tt>AND</tt> and <tt>OR</tt>.</li>
<li>Implement support for <tt>BigDecimal</tt>. This might be possible without full type inference by simply substituting <tt>BigDecimal</tt> for <tt>double</tt> everywhere.</li>
<li>Write an outline of the type inference strategy so implications on the API can be caught.</li>
<li>Decide on how serialized engines will be stored for both maximum load performance and maximum robustness when SEJ evolves.</li>
</ul>

<h3>Suggestions</h3>
<ul class="spaced">
<li>Do a simple writer that generates an Excel worksheet based on an SEJ model. This is for applications that create the SEJ models themselves given legacy data or formulas defined in a custom UI. They can then write out a template spreadsheet for when users want to switch to spreadsheet mode.</li>
</ul>

<h2>March 21, 2006</h2>
<p>Everything is up and running again except for:</p>
<ul compact class="compact">
<li>empty cells</li>
<li>strings</li>
<li>INDEX and MATCH</li>
<li>subsections (bands)</li>
<li>binding outputs with parameters (needed for interactive demo)</li>
</ul>

<h2>March 18, 2006</h2>
<p>Just finished reading <em>Better, faster, lighter Java</em>. It made me realize I have to think a bit more about the exceptions I expose. Here are my rules:</p>
<ul class="spaced">
<li>Anything that is a violation of the API contract should not be a declared exception. This is not a situation you want to catch, it is one you want to avoid.</li>
<li>All internal exceptions should be converted to SEJ-specific exceptions (with <tt>cause</tt> set appropriately) so client code is not affected when loader, compiler, or engine implementations are swapped.</li>
<li>Separate phases. Model errors, compiler errors, and computation errors should not be mixed up.</li>
</ul>

<h5>throws</h5>
<p>I also did some experiments about what happens when input methods throw declared exceptions. It is as I suspected: the processing of <tt>throws</tt> is purely a compiler thing. The VM does not enforce adherence. So if you have an input method like this:</p>
<pre>  public String readFile( String _name ) throws IOException  ...</pre>

<p>and use it in a computation that you bind to an output method like this:</p>
<pre>  public abstract String getData();</pre>

<p>the output method generated by SEJ will be able to actually throw the undeclared <tt>IOException</tt>!</p>
<p>Since the list of declared thrown exceptions is available through reflection, I think SEJ should, in the future, propagate them through computations and check that bound output methods conform to them. This will be mandatory for the source generator anyway, as it needs to properly place <tt>throws</tt> clauses on the generated methods.</p>

<h5>Usability</h5>
<p>I shall have to put a façade on the current compiler interface to simplify engine definition. In particular, this façade will handle section scopes and the lookup of both cell names and the methods on the supplied input/output types.</p>
<p>I shall probably also add convenience classes that fully automate engine definition through reflection and cell names in Excel.</p>

<h2>March 16, 2006</h2>
<p>It's done. I've rewritten the API and ported to old byte-code compiler over to the new design.</p>
<p>I think I shall use version numbers in the class name for the runtime support for the engine. That way, I can easily support multiple versions of stored engines. As long as the implemented interfaces on the engines don't change, that is.</p><dt>Bill Venners <a href="http://www.artima.com/insidejvm/ed2/security2.html">writes</a></dt><dd><em>Although you can grant special access privileges between types belonging to the same package by giving members protected or package access, this special access is granted to members of the same package at runtime only if they were loaded by the same class loader.</em></dd>
<p>This means one has to declare all interfaces to the engine (inputs and outputs) public, even though they very clearly should often be at most package visible.</p>

<h5>Typing</h5>
<p>Right now, the engine supports only <tt>double</tt>-valued computations. It already extends this to <tt>Date</tt>s by simply converting between doubles and dates in the input interface. The output interface does not handle this yet. For the near future, booleans will be handled as doubles too. Excel internally uses 0 for false, 1 for true (and, yes, you can add them).</p>
<p>Which leaves me with the need for data type analysis only for strings and integers. Strings are essential in the long run. Integers (and longs) would allow much faster pure integer computations.</p>

<h2>March 10, 2006</h2>
<p>I have decided to drop support for the interpreted engine. Still need to verify this with Claudio, though. It will make the API much simpler, in particular the provision of default implementations for output methods not bound to the sheet. And it will let me concentrate my efforts on the one implementation that will deliver the best performance anyway.</p>
<p>The reason is that the interpreted engine cannot support the construction of a computation that descends from a user-supplied base class. If this is possible, however, the specification of the output interface, including default behaviour, becomes very simple. The user simply writes a base class that SEJ should descend the generated computation from. This class can either be abstract, partially abstract, or fully implemented with default behaviour for all getters.</p>
<p>What's more, since a generated byte-code class will be very much self-contained and rely only on a few interfaces to support classes, the long-term compatibility of the generated engines will be much improved.</p>

<h2>March 8, 2006</h2>
<p>Started <a href="tutorial.htm">tutorial</a>. Realized that the old API can be replaced by the new, interface-based one (which is the more common case anyway).</p>

<h2>March 7, 2006</h2>
<p>When you have an input interface that throws an exception, Java's reflection mechanism converts that to an <tt>InvocationTargetException</tt>. In order to be able to catch this exception when accessing an output cell, however, you have to declare <tt>InvocationTargetException</tt> on the output interface. If you don't, Java will throw an <tt>UndeclaredThrowableException</tt>.</p>
<p>I have rethought the interface based API. There is an incomplete prototype in the scratchpad right now. I still need to flesh out the sample implementation both for a generic and a byte-code implementation.</p>

<h5>Labels</h5>
<p>I discovered that Excel can accept cell <em>labels</em> in formulas. This means you can actually do something like:</p>
<pre>   A       B
1  f(10)   100
2  x(20)   200
3  Result  =f(10) + x(20)</pre>

<p>Not bad, eh? I don't know, however, whether JExcelAPI handles this properly.</p>

<h2>March 1, 2006</h2>
<p>The next steps I take with SEJ should help to finalize the API. They are:</p>
<ul class="spaced">
<li>Introduce the <tt>interface</tt> based binding. Make it so that for native code compilers, this can be as efficient as possible, obviating the need for all by-name lookups. Interface-based binding should support parametrized inputs, for example YA_1000 -&gt; getYA( 1000 ). Support multiple input interfaces.</li>
<li>Introduce API for names in model so compiler definition code can react to definitions.</li>
<li>Clean up handling of bands. Rethink terminology (again).</li>
<li>Write an outline of the type inference strategy so implications on the API can be caught.</li>
<li>Write a tutorial for both by-name an by-interface binding, including bands and values provided by callbacks.</li>
<li>Decide on how serialized engines will be stored for both maximum load performance and maximum robustness when SEJ evolves.</li>
</ul>

<h4>Bands</h4>
<p>I think bands should not be automatically extended across the entire width or height of the spreadsheet. This would allow one to build spreadsheets like:</p>
<pre>  Location     In       Out
  One          SUM(In)  SUM(Out)    =B-C
               $100     $50
               $200     $80
  Another      SUM(In)  SUM(Out)    =B-C
               $100     $200</pre>

<p>One would define a top-level range A2:D5 and two sub-ranges B3:B4 and C3:C4. This means that the number of <em>Ins</em> may differ from the number of <em>Outs</em>.</p>
<p>Also, the API <tt>Compiler.defineBand()</tt> is not precise. A <em>band</em>, in its accustomed meaning in report definition tools is the template for a single instance. SEJ's API, however, wants to to pass the range encompassing <em>all</em> of the sample instances in the sheet. This is also unfortunate because it makes SEJ assume that a single instances is always just one row high or one column wide. This may not always be convenient for the user.</p>
<p>SEJ does not handle sums over nested bands properly. The user must model intermediate sums for every non-leaf band. I shall accept this as a known limitation for the moment and have <a href="doc/bands.html">documented</a> it.</p>        </div>
        <div class="footer">
<p>Copyright &copy; 2006 Peter Arrenbrecht. All rights reserved.
<br/>Last updated on 10.05.2006.</p>        </div>
    </div>
</body>
</html>