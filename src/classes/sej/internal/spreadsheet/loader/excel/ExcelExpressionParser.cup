package sej.internal.spreadsheet.loader.excel;

import java.util.Collection;
import java.util.ArrayList;
import java_cup.runtime.*;
import sej.*;
import sej.internal.expressions.*;
import sej.internal.spreadsheet.*;

parser code {:

	ExcelExpressionParser excelParser;
	ExpressionNode rootNode;

	@Override
	public void syntax_error( Symbol _cur_token )
	{
		done_parsing();
		throw new RuntimeException( "Unsupported element" );
	}
	
:}

action code {:

	private ExpressionNode cell( ExpressionNode _node ) throws SpreadsheetException
	{
		return this.parser.excelParser.makeCellExpr( _node );
	}

:}

terminal PLUS, MINUS, TIMES, DIV, EXP, PERCENT, CONCAT, COMMA, COLON;
terminal LPAREN, RPAREN, LBRACK, RBRACK;
terminal EQUAL, NOTEQUAL, GREATER, GREATEROREQUAL, LESS, LESSOREQUAL;
terminal IF, AND, OR, NOT;
terminal SUM, PRODUCT, COUNT, AVERAGE, MIN, MAX;
terminal MATCH, INDEX, ROUND, ABS;
terminal TODAY;
terminal CONCATENATE, LEN, MID, LEFT, RIGHT, SUBSTITUTE, REPLACE, SEARCH, FIND, EXACT, LOWER, UPPER, PROPER;
terminal Integer INT;
terminal Double DBL;
terminal String STRING;
terminal String NAME;
terminal String SHEET;
terminal String CELLA1;
terminal String CELLR1C1;
terminal String COL;
terminal String ROW;

non terminal expr_root;
non terminal ExpressionNode expr;
non terminal ExpressionNode optexpr;
non terminal ExpressionNode arg;
non terminal ExpressionNode optarg;
non terminal ExpressionNode rangeexpr;
non terminal ExpressionNode shapedrangeexpr;
non terminal Collection<ExpressionNode> args;
non terminal CellIndex cell;
non terminal CellRange range;
non terminal ExpressionNode rangeunion;
non terminal ExpressionNode rangeintersection;
non terminal Aggregator agg;
non terminal ExpressionNode concat;

precedence left EQUAL, NOTEQUAL, GREATER, GREATEROREQUAL, LESS, LESSOREQUAL;
precedence left CONCAT;
precedence left PLUS, MINUS;
precedence left TIMES, DIV;
precedence left EXP;
precedence left PERCENT;


expr_root ::=

		expr:e
				{: this.parser.rootNode = e; :}

	;
	
	
cell ::=

		CELLA1:c
				{: RESULT = this.parser.excelParser.parseCellRefA1( c ); :}

	|	CELLR1C1:c
				{: RESULT = this.parser.excelParser.parseCellRefR1C1( c ); :}

	|	SHEET:s CELLA1:c
				{: RESULT = this.parser.excelParser.parseCellRefA1( c, s ); :}

	|	SHEET:s CELLR1C1:c
				{: RESULT = this.parser.excelParser.parseCellRefR1C1( c, s ); :}

	;
	
	
range ::=

		cell:a COLON cell:b
				{: RESULT = new CellRange( a, b ); :}
				
	|	COL:a
				{: RESULT = this.parser.excelParser.parseVectorRefCol( a, a ); :}

	|	COL:a COLON COL:b
				{: RESULT = this.parser.excelParser.parseVectorRefCol( a, b ); :}

	|	ROW:a
				{: RESULT = this.parser.excelParser.parseVectorRefRow( a, a ); :}

	|	ROW:a COLON ROW:b
				{: RESULT = this.parser.excelParser.parseVectorRefRow( a, b ); :}

	;

	
rangeexpr ::=

		range:r
				{: RESULT = this.parser.excelParser.newNodeForReference( r ); :}
	
	|	expr:e
				{: RESULT = this.parser.excelParser.makeRangeExpr( e ); :}

	;
	
	
shapedrangeexpr ::=

		rangeexpr:r
				{: RESULT = new ExpressionNodeForRangeShape( r ); :}
				
	;

	
expr ::=

		INT:n				
				{: RESULT = new ExpressionNodeForConstantValue( new Double(n) ); :}
				
	|	DBL:n				
				{: RESULT = new ExpressionNodeForConstantValue( n ); :}
				
	|	STRING:s
				{: RESULT = new ExpressionNodeForConstantValue( this.parser.excelParser.stripFirstAndLastCharOf( s )); :}
				
	|	NAME:n
				{: RESULT = this.parser.excelParser.newNodeForReference( this.parser.excelParser.parseNamedRef( n )); :}
				
	|	cell:c
				{: RESULT = this.parser.excelParser.newNodeForReference( c ); :}
				
	|   MINUS expr:e
				{: RESULT = new ExpressionNodeForOperator( Operator.MINUS, cell( e )); :}
				
	|   PLUS expr:e
				{: RESULT = cell( e ); :}

	|	concat:c
				{: RESULT = c; :}

	|	expr:l PLUS expr:r
				{: RESULT = new ExpressionNodeForOperator( Operator.PLUS, cell( l ), cell( r ) ); :}

	|	expr:l MINUS expr:r
				{: RESULT = new ExpressionNodeForOperator( Operator.MINUS, cell( l ), cell( r ) ); :}

	|	expr:l TIMES expr:r
				{: RESULT = new ExpressionNodeForOperator( Operator.TIMES, cell( l ), cell( r ) ); :}
				
	|	expr:l DIV expr:r
				{: RESULT = new ExpressionNodeForOperator( Operator.DIV, cell( l ), cell( r ) ); :}
				
	|	expr:l EXP expr:r
				{: RESULT = new ExpressionNodeForOperator( Operator.EXP, cell( l ), cell( r ) ); :}
				
	|	expr:e PERCENT
				{: RESULT = new ExpressionNodeForOperator( Operator.PERCENT, cell( e ) ); :}
				
	|	expr:l EQUAL expr:r
				{: RESULT = new ExpressionNodeForOperator( Operator.EQUAL, cell( l ), cell( r ) ); :}

	|	expr:l NOTEQUAL expr:r
				{: RESULT = new ExpressionNodeForOperator( Operator.NOTEQUAL, cell( l ), cell( r ) ); :}

	|	expr:l LESS expr:r
				{: RESULT = new ExpressionNodeForOperator( Operator.LESS, cell( l ), cell( r ) ); :}

	|	expr:l LESSOREQUAL expr:r
				{: RESULT = new ExpressionNodeForOperator( Operator.LESSOREQUAL, cell( l ), cell( r ) ); :}

	|	expr:l GREATER expr:r
				{: RESULT = new ExpressionNodeForOperator( Operator.GREATER, cell( l ), cell( r ) ); :}

	|	expr:l GREATEROREQUAL expr:r
				{: RESULT = new ExpressionNodeForOperator( Operator.GREATEROREQUAL, cell( l ), cell( r ) ); :}

	|	IF LPAREN expr:test COMMA expr:t COMMA expr:f RPAREN
				{: RESULT = new ExpressionNodeForFunction( Function.IF, cell( test ), cell( t ), cell( f )); :}
				
	|	NOT LPAREN expr:arg RPAREN
				{: RESULT = new ExpressionNodeForFunction( Function.NOT, cell( arg )); :}
				
	|	LPAREN expr:e RPAREN
				{: RESULT = cell( e ); :}  // interestingly, you may not parenthesize ranges
				
	|	agg:a LPAREN rangeunion:l RPAREN
				{: RESULT = new ExpressionNodeForAggregator( a, l.arguments() ); :}
				
	|	MATCH LPAREN expr:lookupvalue COMMA shapedrangeexpr:array optarg:matchtype RPAREN
				{: RESULT = new ExpressionNodeForFunction( Function.MATCH, cell( lookupvalue ), array, matchtype ); :}
				
	|	INDEX LPAREN shapedrangeexpr:array arg:rownum optarg:colnum RPAREN
				{: RESULT = new ExpressionNodeForFunction( Function.INDEX, array, rownum, colnum ); :}
	
	|	ROUND LPAREN expr:val COMMA expr:prec RPAREN
				{: RESULT = new ExpressionNodeForFunction( Function.ROUND, cell( val ), cell( prec )); :}	
				
	|	TODAY LPAREN RPAREN
				{: RESULT = new ExpressionNodeForFunction( Function.TODAY ); :}
				
	|	CONCATENATE LPAREN args:a RPAREN
				{: RESULT = new ExpressionNodeForOperator( Operator.CONCAT, a ); :}
				
	|	LEN LPAREN expr:s RPAREN
				{: RESULT = new ExpressionNodeForFunction( Function.LEN, s ); :}
	
	|	MID LPAREN expr:s COMMA expr:start COMMA expr:len  RPAREN
				{: RESULT = new ExpressionNodeForFunction( Function.MID, s, start, len ); :}
	
	|	LEFT LPAREN expr:s optarg:len RPAREN
				{: RESULT = new ExpressionNodeForFunction( Function.LEFT, s, len ); :}
	
	|	RIGHT LPAREN expr:s optarg:len RPAREN
				{: RESULT = new ExpressionNodeForFunction( Function.RIGHT, s, len ); :}
	
	|	SUBSTITUTE LPAREN expr:s COMMA expr:src COMMA expr:tgt optarg:instance RPAREN
				{: RESULT = new ExpressionNodeForFunction( Function.SUBSTITUTE, s, src, tgt, instance ); :}
	
	|	REPLACE LPAREN expr:s COMMA expr:start COMMA expr:len COMMA expr:with RPAREN
				{: RESULT = new ExpressionNodeForFunction( Function.REPLACE, s, start, len, with ); :}
	
	|	EXACT LPAREN expr:a COMMA expr:b RPAREN
				{: RESULT = new ExpressionNodeForFunction( Function.EXACT, a, b ); :}
	
	|	FIND LPAREN expr:what COMMA expr:within optarg:start RPAREN
				{: RESULT = new ExpressionNodeForFunction( Function.FIND, what, within, start ); :}
	
	|	SEARCH LPAREN expr:what COMMA expr:within optarg:start RPAREN
				{: RESULT = new ExpressionNodeForFunction( Function.SEARCH, what, within, start ); :}
	
	|	LOWER LPAREN expr:e RPAREN
				{: RESULT = new ExpressionNodeForFunction( Function.LOWER, e ); :}
	
	|	UPPER LPAREN expr:e RPAREN
				{: RESULT = new ExpressionNodeForFunction( Function.UPPER, e ); :}
	
	|	PROPER LPAREN expr:e RPAREN
				{: RESULT = new ExpressionNodeForFunction( Function.PROPER, e ); :}

	|	ABS LPAREN expr:e RPAREN
				{: RESULT = new ExpressionNodeForFunction( Function.ABS, e ); :}
				
	;


concat ::=

		expr:l CONCAT expr:r
				{: RESULT = new ExpressionNodeForOperator( Operator.CONCAT, cell( l ), cell( r ) ); :}
				
	|	concat:l CONCAT expr:r
				{: l.addArgument( r ); RESULT = l; :}
				
	;
		
	
arg ::=

		COMMA optexpr:e
				{: RESULT = e; :}
	
	;
	
	
optarg ::=

				{: RESULT = null; :}
				
	|	arg:a
				{: RESULT = a; :}
	
	;


optexpr ::=

				{: RESULT = null; :}

	|	expr:e
				{: RESULT = cell( e ); :}
				
	;


args ::=

		expr:e
				{: RESULT = new ArrayList<ExpressionNode>(); RESULT.add( e ); :}
		
	|	args:a COMMA expr:e
				{: a.add( e ); RESULT = a; :}
				
	;

	
agg ::=

		SUM
				{: RESULT = Aggregator.SUM; :}
				
	| 	PRODUCT
				{: RESULT = Aggregator.PRODUCT; :}
				
	| 	COUNT
				{: RESULT = Aggregator.COUNT; :}
				
	| 	AVERAGE
				{: RESULT = Aggregator.AVERAGE; :}
				
	| 	MIN
				{: RESULT = Aggregator.MIN; :}
				
	| 	MAX
				{: RESULT = Aggregator.MAX; :}
				
	| 	AND
				{: RESULT = Aggregator.AND; :}
				
	| 	OR
				{: RESULT = Aggregator.OR; :}
				
	;
	
	
rangeunion ::=

		rangeintersection:r
				{: RESULT = new ExpressionNodeForRangeUnion( r ); :}
				
	|	rangeunion:u COMMA rangeintersection:r
				{: RESULT = u; u.addArgument( r ); :}
	
	;
	
	
rangeintersection ::=

		rangeexpr:r
				{: RESULT = r; :}
				
	|	rangeintersection:i rangeexpr:r
				{: RESULT = (i instanceof ExpressionNodeForRangeIntersection)? i : new ExpressionNodeForRangeIntersection( i ); 
				   RESULT.addArgument( r ); 
				 :}

	;
