package sej.loader.excel;

import java.util.Collection;
import java.util.ArrayList;
import java_cup.runtime.*;
import sej.engine.*;
import sej.engine.expressions.*;
import sej.model.*;

parser code {:
	ExcelExpressionParser excelParser;
	ExpressionNode rootNode;

	@Override
	public void syntax_error( Symbol _cur_token )
	{
		done_parsing();
		throw new RuntimeException( "Unsupported expression element" );
	}
	
:}

terminal PLUS, MINUS, TIMES, DIV, EXP, PERCENT, CONCAT, COMMA, COLON;
terminal LPAREN, RPAREN, LBRACK, RBRACK;
terminal EQUAL, NOTEQUAL, GREATER, GREATEROREQUAL, LESS, LESSOREQUAL;
terminal IF, AND, OR, NOT;
terminal SUM, PRODUCT, AVERAGE, MIN, MAX;
terminal MATCH, INDEX, ROUND;
terminal Integer INT;
terminal Double DBL;
terminal String STRING;
terminal String NAME;
terminal String SHEET;
terminal String CELLA1;
terminal String CELLR1C1;
terminal String COL;
terminal String ROW;

non terminal expr_root;
non terminal ExpressionNode expr;
non terminal ExpressionNode cellexpr;
non terminal ExpressionNode optexpr;
non terminal ExpressionNode arg;
non terminal ExpressionNode optarg;
non terminal ExpressionNode rangeexpr;
non terminal CellIndex cell;
non terminal CellRange range;
non terminal Integer rel;
non terminal Collection rangeexprlist;
non terminal Aggregator agg;

precedence left EQUAL, NOTEQUAL, GREATER, GREATEROREQUAL, LESS, LESSOREQUAL;
precedence left CONCAT;
precedence left PLUS, MINUS;
precedence left TIMES, DIV;
precedence left EXP;
precedence left PERCENT;


expr_root ::=

		expr:e
				{: this.parser.rootNode = e; :}

	;
	
	
cell ::=

		CELLA1:c
				{: RESULT = this.parser.excelParser.parseCellRefA1( c ); :}

	|	CELLR1C1:c
				{: RESULT = this.parser.excelParser.parseCellRefR1C1( c ); :}

	;
	
	
range ::=

		cell:a COLON cell:b
				{: RESULT = new CellRange( a, b ); :}
				
	|	COL:a
				{: RESULT = this.parser.excelParser.parseVectorRefCol( a, a ); :}

	|	COL:a COLON COL:b
				{: RESULT = this.parser.excelParser.parseVectorRefCol( a, b ); :}

	|	ROW:a
				{: RESULT = this.parser.excelParser.parseVectorRefRow( a, a ); :}

	|	ROW:a COLON ROW:b
				{: RESULT = this.parser.excelParser.parseVectorRefRow( a, b ); :}

	;

	
cellexpr ::=

		expr:e
				{: RESULT = this.parser.excelParser.makeCellExpr( e ); :}

	;
	
	
rangeexpr ::=

		range:r
				{: RESULT = this.parser.excelParser.newNodeForReference( r ); :}
				
	|	expr:e
				{: RESULT = this.parser.excelParser.makeRangeExpr( e ); :}

	;
	
	
expr ::=

		INT:n				
				{: RESULT = new ExpressionNodeForConstantValue( new Double(n) ); :}
				
	|	DBL:n				
				{: RESULT = new ExpressionNodeForConstantValue( n ); :}
				
	|	STRING:s
				{: RESULT = new ExpressionNodeForConstantValue( this.parser.excelParser.stripFirstAndLastCharOf( s )); :}
				
	|	NAME:n
				{: RESULT = this.parser.excelParser.newNodeForReference( this.parser.excelParser.parseNamedRef( n )); :}
				
	|	cell:c
				{: RESULT = this.parser.excelParser.newNodeForReference( c ); :}
				
	|   MINUS cellexpr:e
				{: RESULT = new ExpressionNodeForOperator( Operator.MINUS, e ); :}
				
	|   PLUS cellexpr:e
				{: RESULT = e; :}
				
	|	cellexpr:l CONCAT cellexpr:r
				{: RESULT = new ExpressionNodeForOperator( Operator.CONCAT, l, r ); :}

	|	cellexpr:l PLUS cellexpr:r
				{: RESULT = new ExpressionNodeForOperator( Operator.PLUS, l, r ); :}

	|	cellexpr:l MINUS cellexpr:r
				{: RESULT = new ExpressionNodeForOperator( Operator.MINUS, l, r ); :}

	|	cellexpr:l TIMES cellexpr:r
				{: RESULT = new ExpressionNodeForOperator( Operator.TIMES, l, r ); :}
				
	|	cellexpr:l DIV cellexpr:r
				{: RESULT = new ExpressionNodeForOperator( Operator.DIV, l, r ); :}
				
	|	cellexpr:l EXP cellexpr:r
				{: RESULT = new ExpressionNodeForOperator( Operator.EXP, l, r ); :}
				
	|	cellexpr:e PERCENT
				{: RESULT = new ExpressionNodeForOperator( Operator.PERCENT, e ); :}
				
	|	cellexpr:l EQUAL cellexpr:r
				{: RESULT = new ExpressionNodeForOperator( Operator.EQUAL, l, r ); :}

	|	cellexpr:l NOTEQUAL cellexpr:r
				{: RESULT = new ExpressionNodeForOperator( Operator.NOTEQUAL, l, r ); :}

	|	cellexpr:l LESS cellexpr:r
				{: RESULT = new ExpressionNodeForOperator( Operator.LESS, l, r ); :}

	|	cellexpr:l LESSOREQUAL cellexpr:r
				{: RESULT = new ExpressionNodeForOperator( Operator.LESSOREQUAL, l, r ); :}

	|	cellexpr:l GREATER cellexpr:r
				{: RESULT = new ExpressionNodeForOperator( Operator.GREATER, l, r ); :}

	|	cellexpr:l GREATEROREQUAL cellexpr:r
				{: RESULT = new ExpressionNodeForOperator( Operator.GREATEROREQUAL, l, r ); :}

	|	IF LPAREN cellexpr:test COMMA cellexpr:t COMMA cellexpr:f RPAREN
				{: RESULT = new ExpressionNodeForIf( test, t, f ); :}
				
	|	NOT LPAREN cellexpr:arg RPAREN
				{: RESULT = new ExpressionNodeForFunction( Function.NOT, arg ); :}
				
	|	LPAREN cellexpr:e RPAREN
				{: RESULT = e; :}
				
	|	agg:a LPAREN rangeexprlist:l RPAREN
				{: RESULT = new ExpressionNodeForAggregator( a, l ); :}

	|	MATCH LPAREN cellexpr:lookupvalue COMMA rangeexpr:array optarg:matchtype RPAREN
				{: RESULT = new ExpressionNodeForFunction( Function.MATCH, lookupvalue, array, matchtype ); :}
				
	|	INDEX LPAREN rangeexpr:array arg:rownum optarg:colnum RPAREN
				{: RESULT = new ExpressionNodeForFunction( Function.INDEX, array, rownum, colnum ); :}
	
	|	ROUND LPAREN cellexpr:val COMMA cellexpr:prec RPAREN
				{: RESULT = new ExpressionNodeForFunction( Function.ROUND, val, prec ); :}	
				
	;

	
arg ::=

		COMMA optexpr:e
				{: RESULT = e; :}
	
	;
	
	
optarg ::=

				{: RESULT = null; :}
				
	|	arg:a
				{: RESULT = a; :}
	
	;


optexpr ::=

				{: RESULT = null; :}

	|	cellexpr:e
				{: RESULT = e; :}
				
	;
	
	
agg ::=

		SUM
				{: RESULT = Aggregator.SUM; :}
				
	| 	PRODUCT
				{: RESULT = Aggregator.PRODUCT; :}
				
	| 	AVERAGE
				{: RESULT = Aggregator.AVERAGE; :}
				
	| 	MIN
				{: RESULT = Aggregator.MIN; :}
				
	| 	MAX
				{: RESULT = Aggregator.MAX; :}
				
	| 	AND
				{: RESULT = Aggregator.AND; :}
				
	| 	OR
				{: RESULT = Aggregator.OR; :}
				
	;
	
	
rangeexprlist ::=

		rangeexpr:r
				{: RESULT = (new ArrayList<ExpressionNode>()); RESULT.add( r ); :}
				
	|	rangeexprlist:l COMMA rangeexpr:r
				{: RESULT = l; l.add( r ); :}
	
	;
