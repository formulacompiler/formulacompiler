package sej.loader.excel;

import java.util.Collection;
import java.util.ArrayList;
import java_cup.runtime.*;
import sej.engine.*;
import sej.engine.expressions.*;
import sej.model.*;

parser code {:
	ExcelExpressionParser excelParser;
	ExpressionNode rootNode;
:}

terminal PLUS, MINUS, TIMES, DIV, EXP, PERCENT, CONCAT, COMMA, COLON, DOLLAR;
terminal LPAREN, RPAREN, LBRACK, RBRACK;
terminal EQUAL, NOTEQUAL, GREATER, GREATEROREQUAL, LESS, LESSOREQUAL;
terminal IF, AND, OR, NOT;
terminal SUM, PRODUCT, AVERAGE, MIN, MAX;
terminal MATCH, INDEX, ROUND;
terminal Integer INT;
terminal Double DBL;
terminal String STRING;
terminal String IDENT;

non terminal expr_root;
non terminal ExpressionNode expr;
non terminal ExpressionNode optexpr;
non terminal ExpressionNode arg;
non terminal ExpressionNode optarg;
non terminal ExpressionNode rangeexpr;
non terminal CellIndex cell;
non terminal CellIndex cellcoords;
non terminal CellRange range;
non terminal Integer rel;
non terminal Collection rangeexprlist;
non terminal Aggregator agg;

precedence left EQUAL, NOTEQUAL, GREATER, GREATEROREQUAL, LESS, LESSOREQUAL;
precedence left CONCAT;
precedence left PLUS, MINUS;
precedence left TIMES, DIV;
precedence left EXP;
precedence left PERCENT;


expr_root ::=
		expr:e
				{: this.parser.rootNode = e; :}
	;
	
	
expr ::=
		INT:n				
				{: RESULT = new ExpressionNodeForConstantValue( new Double(n) ); :}
				
	|	DBL:n				
				{: RESULT = new ExpressionNodeForConstantValue( n ); :}
				
	|	STRING:s
				{: RESULT = new ExpressionNodeForConstantValue( this.parser.excelParser.stripFirstAndLastCharOf( s )); :}
				
	|	cell:r
				{: RESULT = this.parser.excelParser.newNodeForReference( r ); :}
				
	|   MINUS expr:e
				{: RESULT = new ExpressionNodeForOperator( Operator.MINUS, e ); :}
				
	|	expr:l CONCAT expr:r
				{: RESULT = new ExpressionNodeForOperator( Operator.CONCAT, l, r ); :}

	|	expr:l PLUS expr:r
				{: RESULT = new ExpressionNodeForOperator( Operator.PLUS, l, r ); :}

	|	expr:l MINUS expr:r
				{: RESULT = new ExpressionNodeForOperator( Operator.MINUS, l, r ); :}

	|	expr:l TIMES expr:r
				{: RESULT = new ExpressionNodeForOperator( Operator.TIMES, l, r ); :}
				
	|	expr:l DIV expr:r
				{: RESULT = new ExpressionNodeForOperator( Operator.DIV, l, r ); :}
				
	|	expr:l EXP expr:r
				{: RESULT = new ExpressionNodeForOperator( Operator.EXP, l, r ); :}
				
	|	expr:e PERCENT
				{: RESULT = new ExpressionNodeForOperator( Operator.PERCENT, e ); :}
				
	|	expr:l EQUAL expr:r
				{: RESULT = new ExpressionNodeForOperator( Operator.EQUAL, l, r ); :}

	|	expr:l NOTEQUAL expr:r
				{: RESULT = new ExpressionNodeForOperator( Operator.NOTEQUAL, l, r ); :}

	|	expr:l LESS expr:r
				{: RESULT = new ExpressionNodeForOperator( Operator.LESS, l, r ); :}

	|	expr:l LESSOREQUAL expr:r
				{: RESULT = new ExpressionNodeForOperator( Operator.LESSOREQUAL, l, r ); :}

	|	expr:l GREATER expr:r
				{: RESULT = new ExpressionNodeForOperator( Operator.GREATER, l, r ); :}

	|	expr:l GREATEROREQUAL expr:r
				{: RESULT = new ExpressionNodeForOperator( Operator.GREATEROREQUAL, l, r ); :}

	|	LPAREN expr:e RPAREN
				{: RESULT = e; :}
				
	|	IF LPAREN expr:test COMMA expr:t COMMA expr:f RPAREN
				{: RESULT = new ExpressionNodeForIf( test, t, f ); :}
				
	|	NOT LPAREN expr:arg RPAREN
				{: RESULT = new ExpressionNodeForFunction( Function.NOT, arg ); :}
				
	|	agg:a LPAREN rangeexprlist:l RPAREN
				{: RESULT = new ExpressionNodeForAggregator( a, l ); :}
				
	|	MATCH LPAREN expr:lookupvalue COMMA rangeexpr:array optarg:matchtype RPAREN
				{: RESULT = new ExpressionNodeForFunction( Function.MATCH, lookupvalue, array, matchtype ); :}
				
	|	INDEX LPAREN rangeexpr:array arg:rownum optarg:colnum RPAREN
				{: RESULT = new ExpressionNodeForFunction( Function.INDEX, array, rownum, colnum ); :}
	
	|	ROUND LPAREN expr:val COMMA expr:prec RPAREN
				{: RESULT = new ExpressionNodeForFunction( Function.ROUND, val, prec ); :}			
	;
	
	
optexpr ::=

				{: RESULT = null; :}

	|	expr:e
				{: RESULT = e; :}
				
	;
	
	
arg ::=

		COMMA optexpr:e
				{: RESULT = e; :}
	
	;
	
	
optarg ::=

				{: RESULT = null; :}
				
	|	arg:a
				{: RESULT = a; :}
	
	;
	

cell ::=

		IDENT:i
				{: RESULT = this.parser.excelParser.parseIdentIntoCellRef( i ); :}
				
	|	cellcoords:c
				{: RESULT = c; :}
		
	;
	
	
cellcoords ::=
	
		IDENT:ir rel:c
				{: RESULT = this.parser.excelParser.parseIdentIntoCellIndex( ir, null, null, c ); :}
		
	|	IDENT:ir rel:r IDENT:ic
				{: RESULT = this.parser.excelParser.parseIdentIntoCellIndex( ir, r, ic, null ); :}
		
	|	IDENT:ir rel:r IDENT:ic rel:c
				{: RESULT = this.parser.excelParser.parseIdentIntoCellIndex( ir, r, ic, c ); :}
				
	|	DOLLAR IDENT:cell
				{: RESULT = this.parser.excelParser.parseIdentIntoCellIndex( cell ); :}
				
	|	DOLLAR IDENT:col DOLLAR INT:row
				{: RESULT = this.parser.excelParser.parseIdentIntoCellIndexColRow( col, row ); :}
				
	|	IDENT:col DOLLAR INT:row
				{: RESULT = this.parser.excelParser.parseIdentIntoCellIndexColRow( col, row ); :}
				
	;
				

range ::=
	
		cell:a COLON cell:b
				{: RESULT = new CellRange( (CellIndex)a, (CellIndex)b ); :}
				
	;

	
rel ::=

		LBRACK INT:i RBRACK
				{: RESULT = i; :}
				
	|	LBRACK MINUS INT:i RBRACK
				{: RESULT = -i; :}
				
	;


agg ::=

		SUM
				{: RESULT = Aggregator.SUM; :}
				
	| 	PRODUCT
				{: RESULT = Aggregator.PRODUCT; :}
				
	| 	AVERAGE
				{: RESULT = Aggregator.AVERAGE; :}
				
	| 	MIN
				{: RESULT = Aggregator.MIN; :}
				
	| 	MAX
				{: RESULT = Aggregator.MAX; :}
				
	| 	AND
				{: RESULT = Aggregator.AND; :}
				
	| 	OR
				{: RESULT = Aggregator.OR; :}
				
	;
	
	
rangeexprlist ::=

		rangeexpr:r
				{: RESULT = (new ArrayList<ExpressionNode>()); RESULT.add( r ); :}
				
	|	rangeexprlist:l COMMA rangeexpr:r
				{: RESULT = l; l.add( r ); :}
	
	;
	
rangeexpr ::=

		range:r
				{: RESULT = this.parser.excelParser.newNodeForReference( r ); :}

	|	expr:e
				{: RESULT = e; :}

	;